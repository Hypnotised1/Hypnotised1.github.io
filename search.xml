<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apriori算法</title>
    <url>/apriori.html</url>
    <content><![CDATA[<h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>Apriori算法是R.Agrawal和R.Srikant于1994年提出的为布尔关联规则挖掘频繁项集的原创性算法。算法基于这样的事实：算法使用频繁项集性质的先验知识。Apriori使用一种称作逐层搜索的迭代方法，$k$项集用于探索$(k+1)$项集。首先，通过扫描数据库，累积每个项的计数，并收集满足最小支持度的项，找出频繁$1$项集的集合，该集合记做$L_1$。然后，$L_1$用于找频繁$2$项集的集合$L_2$，$L_2$用于找$L_3$，如此下去，直到不能再找到频繁$k$项集。</p>
<span id="more"></span>
<p><strong>Apriori性质：频繁项集的所有非空子集也必须是频繁的。</strong></p>
<p>利用Apriori算法找出频繁项集需要两个步骤，连接和剪枝</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>为找$L_k$，通过将$L_{k-1}$与自身连接产生候选$k$项集的集合。该候选项集合记作$C_k$。设$l_1$和$l_2$是$L_{k-1}$中的项集。记号$l_i[j]$表示$l_i$中的第$j$项（例如，$l_1[k-2]$表示$l_1$的倒数第二项）。为方便起见，Apriori假定事务或项集中的项按照字典次序排序。对于$(k-1)$项集$l_1$，意味将项排序，使$l_i[1]&lt;l_i[2]&lt;\cdots&lt;l_i[k-1]$。执行连接$L_{k-1}\bowtie L_{k-1}$，如果它们的前$(k-2)$个项相同的话，那么$L_{k-1}$的元素是可连接的（即，如果$$(l_1[1]=l_2[1])\wedge(l_1[2]=l_2[2])\wedge\cdots\wedge(l_1[k-2]=l_2[k-2])\wedge(l_1[k-1]&lt;l_2[k-1])$$，那么$L_{k-1}$的元素$l_1$和$l_2$是可连接的）。条件$(l_1[k-1]&lt;l_2[k-1])$仅仅是保证不产生重复。连接$l_1$和$l_2$产生的结果项集是$l_1[1],l_1[2],\cdots,l_1[k-1],l_2[k-1]$。</p>
<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>$C_k$是$L_k$的超集，也就是说，$C_k$的成员可以是频繁也可以不是频繁的，但所有的频繁$k$项集都包含在$C_k$中。扫描数据库，确定$C_k$中每个候选的计数，从而确定$L_k$（即根据定义，计数值不小于最小支持度计数的所有候选是频繁的，从而属于$L_k$）。然而，$C_k$可能很大，这样所涉及的计算量就很大。为了压缩$C_k$，可使用Apriori性质。任何非频繁的$(k-1)$项集都不是频繁$k$项集的子集。因此，如果候选$k$项集的$(k-1)$项子集不在$L_{k-1}$中，则该候选也不可能是频繁的，从而可以从$C_k$中删除。这种子集测试可以使用所有频繁项集的散列树快速完成。</p>
<h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><p>下表为AllElectronics某分店的实物数据</p>
<table>
<thead>
<tr>
<th>TID</th>
<th align="left">商品ID的列表</th>
</tr>
</thead>
<tbody><tr>
<td>T100</td>
<td align="left">I1,I2,I5</td>
</tr>
<tr>
<td>T200</td>
<td align="left">I2,I4</td>
</tr>
<tr>
<td>T300</td>
<td align="left">I2,I3</td>
</tr>
<tr>
<td>T400</td>
<td align="left">I1,I2,I4</td>
</tr>
<tr>
<td>T500</td>
<td align="left">I1,I3</td>
</tr>
<tr>
<td>T600</td>
<td align="left">I2,I3</td>
</tr>
<tr>
<td>T700</td>
<td align="left">I1,I3</td>
</tr>
<tr>
<td>T800</td>
<td align="left">I1,I2,I3,I5</td>
</tr>
<tr>
<td>T900</td>
<td align="left">I1,I2,I3</td>
</tr>
<tr>
<td><br/></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><img src="/images/Apriori%E7%AE%97%E6%B3%95.jpg" alt="候选项集合频繁项集的产生，最小支持度计数为2" title="候选项集合频繁项集的产生，最小支持度计数为2"></p>
<ol>
<li>在算法的每一次迭代，每项都是候选1项集的集合$C_1$的成员。算法简单地扫描所有的事务，对每项的出现次数计数。</li>
<li>假定要求最小支持度计数为2，即$min\_sup=2$（这里谈论的是绝对支持度，使用的是支持度计数，对应的相对支持度为$2/9=22\%$）。可以确定频繁$1$项集的集合$L_1$。它由满足最小支持度的候选$1$项集组成。在我们的例子中，$C_1$中所有候选都满足最小支持度。</li>
<li>为发现频繁$2$项集的集合$L_2$，算法使用$L_1\bowtie L_1$产生候选$2$项集的集合$C_2$。$C_2$由$C_{|L_1|}^{2}$个$2$项集组成。</li>
</ol>
<p><strong>注意：在剪枝步，没有候选从$C_2$中删除，因为这些候选的每个子集都是频繁的。</strong><br>4. 继续扫描$D$中的事务，计算$C_2$中每个候选项集的支持度计数。<br>5. 确定频繁$2$项集的集合$L_2$，它由满足最小支持度的$C_2$中的候选$2$项集组成。<br>6. 候选$3$项集的集合$C_3$的产生详细在下图中。从连接步，首先令<br>$C_3=L_2\bowtie L_2 \{ \{I1,I2,I3 \} , \{ I1,I2,I5 \} , \{ I1,I3,I5 \} , \{ I2,I3,I4 \} , \{ I2,I3,I5 \} , \{ I2,I4,I5 \} \}$<br>根据Apriori性质，频繁项集的所有子集也必须是频繁的，可以确定后4个候选不可能是频繁的。因此，把它们从$C_3$中删除，这样，在此后扫描$D$确定$L_3$时就不必再求它们的计数值。<br><strong>注意：由于Apriori算法使用逐层搜索技术，给定候选$k$项集，只需要检查它们的$k-1$个子集是否频繁。</strong></p>
<blockquote>
<p>a. 连接：<br>$C_3=L_2\bowtie L_2 = \{ \{ I1,I2 \} , \{ I1,I3 \} , \{ I1,I5 \} , \{ I2,I3 \} , \{ I2,I4 \} , \{ I2,I5 \} \}  \bowtie$<br>$ \{ \{ I1,I2 \} , \{ I1,I3 \} , \{ I1,I5 \} , \{ I2,I3 \} , \{ I2,I4 \} , \{ I2,I5 \} \} $<br>$= \{ \{ I1,I2,I3 \} , \{ I1,I2,I5 \} , \{ I1,I3,I5 \} , \{ I2,I3,I4 \} , \{ I2,I3,I5 \} \{ I2,I4,I5 \}  \} $<br>b.剪枝：使用Apriori性质剪枝，频繁项集的所有非空子集也必须是非频繁的。</p>
<ul>
<li>$\{ I1,I2,I3 \}$的$2$项子集是$\{ I1,I2\} , \{ I1,I3\}$ 和 $ \{ I1,I2\}$。$\{ I1,I2,I3 \}$的所有$2$项子集都是$L_2$的元素。因此，$\{ I1,I2,I3 \}$保留在$C_3$中。</li>
<li>$\{ I1,I2,I5 \}$的$2$项子集是$\{ I1,I2\} , \{ I1,I5\}$ 和 $ \{ I2,I5\}$。$\{ I1,I2,I5 \}$的所有$2$项子集都是$L_2$的元素。因此，$\{ I1,I2,I5 \}$保留在$C_3$中。</li>
<li>$\{ I1,I3,I5 \}$的$2$项子集是$\{ I1,I3\} , \{ I1,I5\}$ 和 $ \{ I3,I5\}$。$\{ I3,I5 \}$不是$L_2$的元素。因而不是频繁的。因此，从$C_3$中删除，$\{ I1,I3,I5 \}$保留在中。<br>其他的也都是一样，通过这样的步骤去判断。<br>最终$C_3=\{ \{ I1,I2,I3 \} , \{ I1,I2,I5 \} \}$</li>
</ul>
<ol start="7">
<li>扫描$D$中的事务确定$L_3$，它由满足最小支持度的$C_3$中的候选$3$项集组成。</li>
<li>算法使用$L_3\bowtie L_3$产生候选$4$项集的集合$C_4$。尽管连接产生结果$\{ \{ I1,I2,I3,I5 \} \}$，但是这个项集被剪去，因为它的子集$\{ I2,I3,I5 \}$不是频繁的。这样，$C_4=\emptyset$，算法终止，找出了所有的频繁项集。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/GitCmd.html</url>
    <content><![CDATA[<p>查看帮助文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git help -a</span><br><span class="line">git help -g</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="创建、提交、修改、删除、查看"><a href="#创建、提交、修改、删除、查看" class="headerlink" title="创建、提交、修改、删除、查看"></a>创建、提交、修改、删除、查看</h1><p>创建版本库<br><code>git init</code></p>
<p>将文件添加进入工作区(暂存区)<br><code>git add filename,filename</code></p>
<p>将文件提交至仓库<br><code>git commit -m &quot;提交说明&quot;</code><br>查看仓库状态(可以查看本仓库文件是否经过修改)<br><code>git status</code><br>查看修改内容<br><code>git diff filename</code><br>查看工作区和版本库最新版本区别<br><code>git diff HEAD -- filename</code></p>
<p>放弃工作区修改(两种情况：将文件退回至git add | git commit 之前的状态)<br><code>git checkout -- filename</code></p>
<p>文件git add 后退回至为add状态,需要两步(将暂存区清空,退回至上一步)<br><code>git reset HEAD filename</code><br><code>git checkout -- filename</code></p>
<p>删除文件<br><code>git rm filename</code><br><code>git commit -m &quot;remove filename&quot;</code></p>
<p>删错文件(没有用上面的命令删除)<br><code>git checkout -- filename</code></p>
<h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><p>查看历史修改记录(时间由近到远)<br><code>git log</code><br><code>git log --pretty=oneline</code></p>
<p>版本号—修改说明<br>9a5ab0a322a61185ea0ce38039340505135b65b3 (HEAD -&gt; master) GPL<br>58d20e868b89baa3000c00f7ed6d107df67d4b14 add distributed<br>17decf5b8210e73c65541816f15cf78c945ba83f wrote a readme file</p>
<p>HEAD表示当前版本,上一版本为HEAD^,上上个则为HEAD^^,向上多个版本可以写成 HEAD~15</p>
<p>退回到上个版本<br><code>git reset --hard HEAD^</code><br>回溯至当前版本<br><code>git rest --hard 当前版本号(可以不用写全)</code></p>
<p>查看命令历史<br><code>git reflog</code></p>
<h1 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h1><p>将远程仓库与本地库关联(远程仓库的默认名称是origin)<br><code>git remote add origin git@github.com:Hypnotised1/test.git</code><br>将本地库进行推送<br><code>git push -u origin master</code><br>-u参数指定默认分支,指定后可以直接使用 git push 进行提交<br>查看远程仓库信息<br><code>git remote -v</code><br>推送分支<br><code>git push origin branchname</code></p>
<p>删除远程分支<br><code>git push origin :branchname</code><br>冒号代表删除</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>Git中的主分支是master,HEAD指向的是分支(master或其他分支),master指向提交,从而使得HEAD指向最新的提交.</p>
<p>创建分支<br>git checkout -b branchname,参数b表示创建分支并切换至该分支,可以下面两个命令来表示<br><code>git branch branchname</code><br><code>git checkout branchname:切换至branchname分支</code></p>
<p>查看分支<br><code>git branch</code><br>合并分支(将branchname合并至当前分支,默认采用Fast forward模式),Fast forward模式方便快捷但是删除分支后会丢失分支信息<br><code>git merge branchname</code></p>
<p>删除分支<br><code>git branch -d branchname</code><br>强制删除分支<br><code>git branch -D branchname</code></p>
<p>解决分支冲突(手动解决冲突)<br><code>git merge branchname</code><br>修改文件,重新add,commit</p>
<p>查看分支合并情况<br><code>git log --graph --pretty=oneline --abbrev-commit</code></p>
<p>不使用Fast forward模式进行合并<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; branchname</code><br>-m表示的是进行提交,不使用Fast forward模式在查看分支合并情况时可用看出是进行过提交和修改.</p>
<p>Bug分支:在开发分支上进行开发,还不能提交至主分支,但是出现了bug,需要进行切换至bug分支进行解决<br><code>git stash</code>,将当前工作分区进行储存</p>
<p><code>git stash list</code>,查看工作分区表</p>
<p><code>git stash apply</code>,恢复工作分区, 需要使用git stash drop来删除工作区<br><code>git stash pop</code>,恢复工作分区的同时将该工作区删除<br><code>git stash apply stash@&#123;0&#125;</code> 恢复指定工作分区</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><blockquote>
<p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
</blockquote>
<p>标签,默认是打在最新提交的commit上的<br><code>git tag tagname</code><br><code>git log --pretty=oneline --abbrev-commit</code><br>给历史提交打标签<br><code>git tag tagname commitID(075bc67)</code><br>查看标签信息<br><code>git show tagname</code><br>创建带有说明的表情<br><code>git tag -a v1.1 -m &quot;version 1.1 &quot;</code><br>删除标签<br><code>git tag -d v1.1</code><br>推送标签至远程服务器<br><code>git push origin tagname</code><br>推送所有标签至远程服务器<br><code>git push origin --tags</code><br>删除已经推送至远程的标签:删除本地标签,删除远程标签<br><code>git tag -d v0.9</code><br><code>git push origin :refs/tags/v0.9</code></p>
<h1 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h1><p>添加子模块<br><code>git submodule add git@github.com:Hypnotised1/BlogSource.git</code><br>克隆带子模块的项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:theme-next/test1</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>

<h1 id="忽略特殊文件设置-gitignore"><a href="#忽略特殊文件设置-gitignore" class="headerlink" title="忽略特殊文件设置.gitignore"></a>忽略特殊文件设置.gitignore</h1><p>修改该文件的内容,但是已经纳入版本管理的文件修改.gitignore是无效的,解决办法是先把本地缓存删除,然后再提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;update .gitignore&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>云盘同步命令之mklink</title>
    <url>/Mklink.html</url>
    <content><![CDATA[<p>本文以Onedrive为例, 介绍Windows上进行云盘同步的命令mklink. </p>
<span id="more"></span>

<h1 id="mklink"><a href="#mklink" class="headerlink" title="mklink"></a>mklink</h1><p>mklink是windows系统下创建符号链接的命令, 他可以像创建快捷方式一样创建文件或目录的链接, 但是这两者有着显著的区别.<br>首先在命令(需要管理员权限)行下执行<code>mklink</code>命令, 有三种模式, <code>/D</code>, <code>/H</code>和 <code>/J</code></p>
<p><img src="/images/mklink.png" alt="mklink" title="mklink"></p>
<p>符号链接: 其也被称作软链接, 是一类特殊的文件. 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用. 注意, 符号链接是文件引用.</p>
<p><code>/d</code>: 创建目录符号链接, 默认为目录, 文件则无法打开</p>
<p><code>mklink /d softlinkD sourceDict</code></p>
<p>硬链接: 其与软链接相对, 是一个文件的复制, 当修改一个文件时, 其余所有与之进行硬链接的文件均得到修改. 删除一个时, 其余不会改变. 在移动链接文件时, 如果在同一盘符上进行移动, 可以继续保持链接, 否则无法维系链接, 而且在不同盘符上无法建立硬链接.(在C盘创建的所有硬链接, 如果将其移动至其他盘, 则链接中断.)</p>
<p><code>/h</code>: 创建硬链接, 其只能针对文件, 无法针对文件夹, 当Target为文件夹时会拒绝访问.</p>
<p><code>mklink /h hardlink.txt source.txt</code></p>
<p><code>/j</code>: 创建目录联接, 默认为目录, 文件则无法打开. 与<code>/d</code>的区别是, 使用<code>/d</code>命令创建的链接可以复制剪切与移动, 使用<code>/j</code>命令创建的无法剪切和移动. 本命令常用来进行Onedrive等云盘的同步.</p>
<p><code>mklink /j junction sourceDict</code></p>
<p>各个命令的具体区别如图所示(其中图中第一行<code>/j</code>和<code>/d</code>关于删除链接的操作是不对的, Junction与Symbolic link一样, Target remains unchanged.). 本图来自<a href="https://en.wikipedia.org/wiki/Symbolic_link#NTFS_symbolic_link">维基百科</a></p>
<p><img src="/images/mklink-summ.png" alt="mklink" title="mklink"></p>
<h1 id="Onedrive-同步"><a href="#Onedrive-同步" class="headerlink" title="Onedrive 同步"></a>Onedrive 同步</h1><p>登录好自己的Onedrive, 并设置本地文件夹. 使用下面的命令将Onedrive中的文件夹创建一个Junction link至本地文件夹</p>
<p><code>mklink /j D:\aaa D:\OneDrive\funnyphd\source</code></p>
<p>其中, <code>D:\OneDrive\funnyphd\source</code>为Onedrive在本地的文件夹(源文件), <code>D:\aaa</code>为链接名称. 我们可以通过直接修改aaa目录下的文件来实现文件的自动上传. 如果换台机器, 需要重做上面的操作, 即可实现本地文件与云盘文件同步.</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python调用MATLAB</title>
    <url>/pythonmatlab.html</url>
    <content><![CDATA[<p>R2017b之前的版本支持py2.7-py3.5,R2017b以及之后可支持py3.6</p>
<h1 id="安装MATLAB"><a href="#安装MATLAB" class="headerlink" title="安装MATLAB"></a>安装MATLAB</h1><p>切换目录至 <code>MATLAB\R2018b\extern\engines\python</code>,执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#非默认目录下安装,并把安装信息存至D:\MatlabForPython\files.txt</span><br><span class="line">python setup.py build --build-base=&quot;D:\MatlabForPython&quot; install --record D:\MatlabForPython\files.txt </span><br><span class="line">#默认目录下安装</span><br><span class="line">python setup.py install </span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>matlab文件 getFromMat.m</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a = getFromMat(x)</span><br><span class="line">a=[1 2 3; 4 5 6]</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p>导入包,并启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import matlab.engine</span><br><span class="line">&gt;&gt;&gt; eng=matlab.engine.start_matlab()</span><br></pre></td></tr></table></figure>

<h1 id="python获取matlab函数的执行结果"><a href="#python获取matlab函数的执行结果" class="headerlink" title="python获取matlab函数的执行结果"></a>python获取matlab函数的执行结果</h1><blockquote>
<p>需要将得到的值进行转化,才能得到array类型的数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mat=eng.getFromMat(1)</span><br><span class="line">a =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">x =</span><br><span class="line">  int64</span><br><span class="line">   1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.array(mat._data).reshape(mat.size[::-1]).T</span><br><span class="line">array([[1., 2., 3.],</span><br><span class="line">       [4., 5., 6.]])</span><br></pre></td></tr></table></figure>

<h1 id="将python数据传入matlab函数"><a href="#将python数据传入matlab函数" class="headerlink" title="将python数据传入matlab函数"></a>将python数据传入matlab函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; aa=np.arange(9).reshape(3,3)</span><br><span class="line">&gt;&gt;&gt; bb=matlab.int8(aa.tolist())</span><br><span class="line">&gt;&gt;&gt; data=eng.triarea(bb)</span><br><span class="line">a =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">x =</span><br><span class="line">  3x3 int8 矩阵</span><br><span class="line">   0   1   2</span><br><span class="line">   3   4   5</span><br><span class="line">   6   7   8</span><br></pre></td></tr></table></figure>


<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matlab.engine</span><br><span class="line">import numpy as np</span><br><span class="line">eng=matlab.engine.start_matlab()</span><br><span class="line">#得到matlab执行结果,并转化为array数据</span><br><span class="line">mat=eng.getFromMat(1)</span><br><span class="line">pymat=np.array(mat._data).reshape(mat.size[::-1]).T</span><br><span class="line"></span><br><span class="line">#将array数据转化为matlab.int,并传入matlab引擎</span><br><span class="line">aa=np.arange(9).reshape(3,3)</span><br><span class="line">bb=matlab.int8(aa.tolist())</span><br><span class="line">data=eng.triarea(bb)</span><br><span class="line"></span><br><span class="line">#关闭matlab引擎</span><br><span class="line">eng.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python操作文件(夹)</title>
    <url>/pythonfile.html</url>
    <content><![CDATA[<p>在日常工作中, 我们有时需要处理大量文件以及文件夹, 本文介绍python中操作文件(夹)的模块<code>os</code>和<code>shutil</code> 以及查看文件状态的模块<code>stat</code>.</p>
<blockquote>
<p>注意: <code>os</code>模块中也有<code>stat</code>函数, 使用方法为<code>os.stat(path, *, dir_fd=None, follow_symlinks=True)</code>, 模块<code>stat</code>为实现<code>os.stat()</code>的底层模块, 可以直接调用该模块查看文件详细信息, 也可以使用<code>os.stat</code>查看文件信息.</p>
</blockquote>
<span id="more"></span>

<p>导入相关模块</p>
<pre><code>import os, stat, shutil
</code></pre>
<p>获取当前目录</p>
<pre><code>os.getcwd()
&gt;&gt;&gt;d:\Github_workspace\
</code></pre>
<p>获取执行文件的目录</p>
<pre><code>os.path.dirname(__file__)
</code></pre>
<p>将目录切换至C盘下的Windows文件夹</p>
<pre><code>os.chdir(&#39;C:/Windows&#39;)
</code></pre>
<p>将目录切换至当前执行文件的文件夹下</p>
<pre><code>os.chdir(os.path.dirname(__file__))
</code></pre>
<p>查看当面目录下所有文件(夹)</p>
<pre><code>os.listdir(path=None)
os.listdir()
&gt;&gt;&gt;[&#39;node_modules&#39;, &#39;package.json&#39;, &#39;public&#39;, &#39;scaffolds&#39;, &#39;source&#39;, &#39;themes&#39;, &#39;_config.yml&#39;]
</code></pre>
<p>文件名和扩展名分离<br>    filaname=’hello.py’<br>    os.path.splitext(filename)<br>    &gt;&gt;&gt;(‘hello’, ‘.py’)</p>
<p>查看文件(夹)信息</p>
<pre><code>os.stat(&#39;./aaa.txt)
&gt;&gt;&gt;os.stat_result(st_mode=33060, st_ino=1125899906847384, st_dev=1511501194, st_nlink=1, st_uid=0, st_gid=0, st_size=26, st_atime=1580096882, st_mtime=1580096858, st_ctime=1580096735)
</code></pre>
<blockquote>
<p>st_mode 文件权限, st_ino 文件的inode(每个文件有单独的一个inode) 如果想要详细了解可以查看<a href="https://www.ruanyifeng.com/blog/2011/12/inode.html">阮一峰的博客</a>, st_dev 文件所在设备, st_nlink 文件的硬链接数, st_uid 文件所有者的用户标识, st_gid 文件所有者的组标识, st_size 文件字节数, st_atime2 最后一次访问的时间(秒), st_mtime 最后一次修改内容的时间(秒), st_ctime 由操作系统报告的”ctime”, 在某些系统上(如Unix)是最新的元数据更改的时间, 在其它系统上(如Windows)是创建时间.</p>
</blockquote>
<p>修改文件(夹)权限</p>
<pre><code>os.chmod(path, mode) #path为文件(夹)的路径(相对路径或者绝对路径都可以), mode为stat.S_IREAD(windows下设为只读), stat.S_IWRITE(windows下取消只读)
os.chmod(&#39;./aaa.txt&#39;,stat.S_IREAD)
</code></pre>
<p>修改文件(夹)名称</p>
<pre><code>os.rename(src, dst) #src为原文件(夹)名称, dst为想要修改的文件(夹)名称
os.rename(&#39;D:/aa/aaa.txt&#39;, &#39;D:/aa/bbb.txt&#39;)
</code></pre>
<p>判断是否是文件(夹)</p>
<pre><code>os.path.isdir(path)/os.path.isfile(path)
os.path.isdir(&#39;D:/aa/aaa.txt&#39;)
&gt;&gt;&gt;False
os.path.isfile(&#39;D:/aa/aaa.txt&#39;)     
&gt;&gt;&gt;True
</code></pre>
<p>判断文件夹是否存在</p>
<pre><code>os.path.exists(path)
os.path.exists(&#39;D:/aa/&#39;)
&gt;&gt;&gt;True
</code></pre>
<p>删除文件(夹)</p>
<pre><code>os.remove(path)/os.rmdir(path)
os.remove(&#39;D:/aa/ccc.txt&#39;)
os.rmdir(&#39;D:/aa/ccc&#39;)
</code></pre>
<p>创建文件夹</p>
<pre><code>os.mkdir(path) #创建文件夹/os.makedirs(path) 多层创建文件夹
os.mkdir(&#39;./aaa/&#39;) 
os.makedirs(&#39;./aaa/bbb/ccc/&#39;) 
</code></pre>
<p>复制文件(夹)</p>
<pre><code>#将文件复制到dst目录, 不会复制文件相关的Metadata, 从而导致修改了文件的相关属性如: 访问时间, 创建时间等
shutil.copy(src, dst, follow_symlinks=Ture) 

#将文件复制到dst目录下, 会复制文件相关的Metadata, 不会修改文件属性
shutil.copy2(src, dst, follow_symlinks=Ture) 

shutil.copy(&#39;D:/aa/aaa.txt&#39;,&#39;D:/aa/ccc.txt&#39;)
&gt;&gt;&gt;&#39;D:/aa/ccc.txt&#39;
shutil.copy(&#39;D:/aa/aaa.txt&#39;,&#39;D:/aa/ddd.txt&#39;)
&gt;&gt;&gt;&#39;D:/aa/ddd.txt&#39;

#与拷贝文件相对应, shutil.copytree为拷贝目录的函数
#默认使用shutil.copy2函数来拷贝文件, 因此文件相关的Metadata会被拷贝
shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)
shutil.copytree(&#39;D:/aa/&#39;,&#39;D:/aa/ccc&#39;)
&gt;&gt;&gt;&#39;D:/aa/ccc&#39;
</code></pre>
<p>移动文件(夹)</p>
<pre><code>shutil.move(src, dst, copy_function=copy2)
shutil.move(&#39;D:/aa/aaa.txt&#39;,&#39;D:/aa/xxx.txt&#39;)
&gt;&gt;&gt;&#39;D:/aa/xxx.txt&#39;
</code></pre>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>策略迭代和值迭代</title>
    <url>/policyvalue.html</url>
    <content><![CDATA[<h1 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h1><p><img src="/images/PolicyIteration.jpg" alt="Policy Iteration"></p>
<span id="more"></span>
<p>1.初始化: 状态值函数$V(s)$和策略$\pi (s)$</p>
<p>2.状态值函数更新: $V(s)=\sum_{s’,r}{p(s’,r|s,\pi (s))[r+\gamma V(s’)]}$</p>
<blockquote>
<p>在计算状态值函数时, 需要对每个状态进行遍历, 在该状态下根据策略选择相应的动作, 从而求得状态值函数. 状态值函数趋于稳定时, 跳转到Policy Improvement阶段.</p>
</blockquote>
<p>3.策略更新:$\pi(s)=argmax_a\sum_{s’,r}{p(s’,r|s,a)[r+\gamma V(s’)]}$</p>
<blockquote>
<p>当在对策略更新时, 需要对所有状态的所有动作进行遍历, 从而得到每个状态的最优执行动作, 也就是得到最优的策略.<br>策略更新完成后重新对新的策略进行更新, 直至策略稳定, 输出策略.</p>
</blockquote>
<h1 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h1><p><img src="/images/ValueIteration.jpg" alt="Value Iteration"></p>
<p>1.初始化: 状态值函数$V(s)$</p>
<p>2.状态值函数更新: $V(s)=max_a\sum_{s’,r}{p(s’,r|s,a)[r+\gamma V(s’)]}$</p>
<blockquote>
<p>在遍历计算状态值函数的过程中, 其计算对每个状态的所有动作的状态值函数$V(s,a)$,从中选取最优的对$V(s)$进行赋值, 当状态值函数趋于稳定, 则跳转至策略输出阶段.</p>
</blockquote>
<p>3.策略找寻(本人翻译):$\pi(s)=argmax_a\sum_{s’,r}{p(s’,r|s,a)[r+\gamma V(s’)]}$</p>
<blockquote>
<p>根据稳定的状态值函数, 遍历所有状态和所有动作, 求得任意一个状态下的最优动作, 从而得到最优策略.</p>
</blockquote>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>通过对这两种算法进行观察, 我们可以得到其区别</p>
<ol>
<li><p>策略迭代需要对策略进行初始化, 值迭代不需要.</p>
</li>
<li><p>状态值函数更新时, 策略迭代只需计算确定策略下的状态值函数, 值迭代需要计算所有动作的状态值函数, 并选取最大的进行赋值.</p>
</li>
<li><p>一个叫策略更新, 一个叫策略找寻(本人翻译), 从字面上就可以看出两者之间的区别, 策略更新需要对策略进行重新赋值, 策略找寻则是根据状态值函数找到对应的策略.</p>
</li>
<li><p>以策略迭代为代表的算法有策略梯度(Policy Gradient), 以值迭代为代表的算法有Q-learning. 其中, 当算法用于连续动作控制时, 优先使用策略迭代算法, 这是因为在使用策略迭代时可以利用Function Approximation来解决动作的连续化问题. 如果使用Q-learning算法, 那么Q Value在面对连续动作时将无可奈何, 只能选择将其离散化, 然后再进行计算.</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy常用函数</title>
    <url>/pythonnumpy.html</url>
    <content><![CDATA[<h1 id="max"><a href="#max" class="headerlink" title="max"></a>max</h1><p>max(a, axis=None, out=None, keepdims=np._NoValue)<br>Return the maximum of an array or maximum along an axis.<br>返回array的最大值或者沿axis轴的最大值</p>
<span id="more"></span>
<h2 id="axis参数详解"><a href="#axis参数详解" class="headerlink" title="axis参数详解"></a>axis参数详解</h2><p>np.max(a,axis)表示在axis轴上取得的最值<br>axis的取值范围为[0,len(a.shape))<br>axis也可以是一个元组axis=(0,1)表示在第一个轴和第二个轴相交的空间上取得的最值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=np.array(</span><br><span class="line">        [[[5., 0., 7., 0.],</span><br><span class="line">        [0., 0., 7., 0.],</span><br><span class="line">        [0., 0., 0., 3.]],</span><br><span class="line"></span><br><span class="line">       [[9., 5., 6., 0.],</span><br><span class="line">        [0., 6., 0., 0.],</span><br><span class="line">        [0., 0., 0., 4.]]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.max(a,axis=0)</span><br><span class="line">a的shape为(2,3,4),axis为0,表示沿着第一轴方向上的最值,可以得到一个(3,4)的array</span><br><span class="line">array([[9., 5., 7., 0.],</span><br><span class="line">       [0., 6., 7., 0.],</span><br><span class="line">       [0., 0., 0., 4.]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.max(a,axis=(0,1))</span><br><span class="line">axis为(0,1),表示在第一轴上和第二轴相交空间上的最值,得到一个(4,)的array</span><br><span class="line">array([9., 6., 7., 4.]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.max(a,axis=(0,1,2))</span><br><span class="line">则等同于np.max(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="where"><a href="#where" class="headerlink" title="where"></a>where</h1><p>where(condition, [x, y])<br>Return elements, either from <code>x</code> or <code>y</code>, depending on <code>condition</code>.If only <code>condition</code> is given, return <code>condition.nonzero()</code>.<br>按照给定<code>condition</code>返回元素<code>x</code>或<code>y</code>.如果只给定<code>condition</code>,则返回<code>condition.nonzero()</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=np.arange(9).reshape(3,3)</span><br><span class="line">&gt;&gt;&gt; np.where(a&gt;3) </span><br><span class="line">#输出为一个二维array,第一行表示a中的行坐标,第二行表示a中列坐标(可延伸至多维)</span><br><span class="line">#a[1,1]=4, a[1,2]=5, a[2,0]=6....a[2,2]=8</span><br><span class="line">(array([1, 1, 2, 2, 2], dtype=int64), array([1, 2, 0, 1, 2], dtype=int64))</span><br><span class="line">&gt;&gt;&gt; a&gt;3</span><br><span class="line">array([[False, False, False],</span><br><span class="line">       [False,  True,  True],</span><br><span class="line">       [ True,  True,  True]])</span><br><span class="line">&gt;&gt;&gt; (a&gt;3).nonzero()</span><br><span class="line">(array([1, 1, 2, 2, 2], dtype=int64), array([1, 2, 0, 1, 2], dtype=int64))</span><br><span class="line"></span><br><span class="line">如果同时给定这三个参数,x和y可以为任意类型的数据,str、tuple、list、int</span><br><span class="line">如果是多维数据其shape必须和condition有一定的联系(进行替换的时候不能有歧义)</span><br><span class="line">&gt;&gt;&gt; np.where(a&gt;3,0,-1)</span><br><span class="line">array([[-1, -1, -1],</span><br><span class="line">       [-1,  0,  0],</span><br><span class="line">       [ 0,  0,  0]])</span><br><span class="line">符合条件的为0,不符合条件为-1</span><br><span class="line"></span><br><span class="line">如果x和y为list,tuple</span><br><span class="line">&gt;&gt;&gt; x=np.arange(-1,-10,-1).reshape(3,3)</span><br><span class="line">&gt;&gt;&gt; np.where(a&gt;3,x,(0))</span><br><span class="line">array([[ 0,  0,  0],</span><br><span class="line">       [ 0, -5, -6],</span><br><span class="line">       [-7, -8, -9]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x=np.arange(-1,-4,-1)</span><br><span class="line">&gt;&gt;&gt; np.where(a&gt;3,x,(0))</span><br><span class="line">array([[ 0,  0,  0],</span><br><span class="line">       [ 0, -2, -3],</span><br><span class="line">       [-1, -2, -3]])</span><br><span class="line"></span><br><span class="line">x和y是多维数据时需要有一定联系,方便进行选择,否则报错</span><br><span class="line">&gt;&gt;&gt; x=np.arange(-1,-7,-1)</span><br><span class="line">&gt;&gt;&gt; np.where(a&gt;3,x,(0))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: operands could not be broadcast together with shapes (3,3) (6,) ()</span><br></pre></td></tr></table></figure>


<h1 id="cumsum"><a href="#cumsum" class="headerlink" title="cumsum"></a>cumsum</h1><p>cumsum(a, axis=None, dtype=None, out=None)<br>Return the cumulative sum of the elements along a given axis.<br>返回给定轴上元素累计和.也可以称作累加函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=np.arange(6).reshape(2,3)</span><br><span class="line">array([[0, 1, 2],</span><br><span class="line">       [3, 4, 5]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.cumsum(a)</span><br><span class="line">array([ 0,  1,  3,  6, 10, 15], dtype=int32)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.cumsum(a,axis=0)</span><br><span class="line">array([[0, 1, 2],</span><br><span class="line">       [3, 5, 7]], dtype=int32)</span><br><span class="line">&gt;&gt;&gt; np.cumsum(a,axis=1)</span><br><span class="line">array([[ 0,  1,  3],</span><br><span class="line">       [ 3,  7, 12]], dtype=int32)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="cumprod"><a href="#cumprod" class="headerlink" title="cumprod"></a>cumprod</h1><p>cumprod(a, axis=None, dtype=None, out=None):<br>Return the cumulative product of elements along a given axis.<br>返回给定轴上元素累计积.也可以称作累积函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=np.arange(1,7).reshape(2,3)</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.cumprod(a)</span><br><span class="line">array([  1,   2,   6,  24, 120, 720], dtype=int32)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.cumprod(a,axis=0)</span><br><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [ 4, 10, 18]], dtype=int32)</span><br><span class="line">&gt;&gt;&gt; np.cumprod(a,axis=1)</span><br><span class="line">array([[  1,   2,   6],</span><br><span class="line">       [  4,  20, 120]], dtype=int32)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>unique</p>
<h1 id="asarray"><a href="#asarray" class="headerlink" title="asarray"></a>asarray</h1><p>asarray(a, dtype=None, order=None)<br>Convert the input to an array.<br>将输入转化为array</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=[1,2,3,4]</span><br><span class="line">&gt;&gt;&gt; a=np.asarray(a)</span><br><span class="line">array([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; np.asarray(a)</span><br><span class="line">array(&#x27;123&#x27;, dtype=&#x27;&lt;U3&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="errstate"><a href="#errstate" class="headerlink" title="errstate"></a>errstate</h1><p>np.errstate(**kwargs)<br>kwargs:{divide,over,under,invalid}<br>关键字参数。有效的关键字是可能的浮点异常。每个关键字都应该有一个字符串值来定义特定错误的处理。可能的值为{‘ignore’,’warn’,’raise’,’call’,’print’,’log’}。</p>
<h1 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h1><p>transpose(a, axes=None)<br>Permute the dimensions of an array.<br>将矩阵a进行转置, 其中当a为一维时不起作用, 转置物理意义为切换坐标轴, 将x轴换为y轴, y轴换为x轴.</p>
<blockquote>
<blockquote>
<blockquote>
<p>aa=np.arange(4).reshape(2,2)<br>aa<br>array([[0, 1],<br>       [2, 3]])<br>bb =aa.transpose()<br>array([[0, 2],<br>       [1, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>#aa.transpose() &lt;===&gt; aa.transpose(1,0), 将0轴(数据下标)换为1轴, 将1轴换为0轴. 如a[0][1] 变换为 bb[1][0]</p>
<blockquote>
<blockquote>
<blockquote>
<p>aa=np.arange(27).reshape(-1,3,3)<br>aa<br>array([[[ 0,  1,  2],<br>        [ 3,  4,  5],<br>        [ 6,  7,  8]],</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>   [[ 9, 10, 11],
    [12, 13, 14],
    [15, 16, 17]],

   [[18, 19, 20],
    [21, 22, 23],
    [24, 25, 26]]])
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>bb=aa.transpose()<br>array([[[ 0,  9, 18],<br>        [ 3, 12, 21],<br>        [ 6, 15, 24]],</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>   [[ 1, 10, 19],
    [ 4, 13, 22],
    [ 7, 16, 25]],

   [[ 2, 11, 20],
    [ 5, 14, 23],
    [ 8, 17, 26]]])
</code></pre>
<p>#此时 aa.transpose() &lt;===&gt; aa.transpose(2,1,0), 将0轴换为2轴, 1轴不变, 2轴换为0轴. 如 aa[2][1][0] 变换为 bb[0][1][2]</p>
<blockquote>
<blockquote>
<blockquote>
<p>bb= aa.transpose(2,0,1)<br>array([[[ 0,  3,  6],<br>        [ 9, 12, 15],<br>        [18, 21, 24]],</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>   [[ 1,  4,  7],
    [10, 13, 16],
    [19, 22, 25]],

   [[ 2,  5,  8],
    [11, 14, 17],
    [20, 23, 26]]])
</code></pre>
<p>#同理, aa[2][0][1] == bb[1][2][0]</p>
<h1 id="clip"><a href="#clip" class="headerlink" title="clip"></a>clip</h1><p>clip(a, a_min, a_max, out=None)<br>    Clip (limit) the values in an array.</p>
<p>将a限制在a_min, a_max内, </p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(10)<br>np.clip(a, 1, 8)<br>array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])<br>np.clip(a, 1, 8) &lt;===&gt; b=np.where(a&lt;1, 1, a) 和 b =np.where(b&gt;8,8,b)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="设置精度"><a href="#设置精度" class="headerlink" title="设置精度"></a>设置精度</h1><p>np.set_printoptions(precision=2)</p>
<h1 id="np-squeeze"><a href="#np-squeeze" class="headerlink" title="np.squeeze"></a>np.squeeze</h1><h1 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h1><p>随机初始化数组</p>
<h1 id="genfromtxt"><a href="#genfromtxt" class="headerlink" title="genfromtxt"></a>genfromtxt</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def genfromtxt(fname, dtype=float, comments=&#x27;#&#x27;, delimiter=None,</span><br><span class="line">       skip_header=0, skip_footer=0, converters=None,</span><br><span class="line">       missing_values=None, filling_values=None, usecols=None,</span><br><span class="line">       names=None, excludelist=None,</span><br><span class="line">       deletechars=&#x27;&#x27;.join(sorted(NameValidator.defaultdeletechars)),</span><br><span class="line">       replace_space=&#x27;_&#x27;, autostrip=False, case_sensitive=True,</span><br><span class="line">       defaultfmt=&quot;f%i&quot;, unpack=None, usemask=False, loose=True,</span><br><span class="line">       invalid_raise=True, max_rows=None, encoding=&#x27;bytes&#x27;):</span><br></pre></td></tr></table></figure>
<p>Load data from a text file, with missing values handled as specified.<br>Each line past the first <code>skip_header</code> lines is split at the <code>delimiter</code><br>character, and characters following the <code>comments</code> character are discarded.</p>
<h1 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h1><blockquote>
<blockquote>
<blockquote>
<p>np.identity(3)<br>array([[1.,  0.,  0.],<br>       [0.,  1.,  0.],<br>       [0.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="numpy-ndarray-flatten"><a href="#numpy-ndarray-flatten" class="headerlink" title="numpy.ndarray.flatten()"></a>numpy.ndarray.flatten()</h1>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda Python 环境管理</title>
    <url>/anacondahelp.html</url>
    <content><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p><a href="https://www.anaconda.com/">Anaconda</a>就是可以便捷获取包且对包能够进行管理, 同时对环境可以统一管理的发行版本. Anaconda包含了conda, Python在内的超过180个科学包及其依赖项. 而且其可以对不同的Python环境进行隔离, 举个例子, 如果需要同时创建python2.7 和python3.5的环境, 我们有两种方式, 一种是使用virtualenv(虚拟环境)来创建, 另外一种方式是使用anaconda 创建. </p>
<span id="more"></span>

<h1 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a>Anaconda 安装</h1><h1 id="Anaconda环境的管理"><a href="#Anaconda环境的管理" class="headerlink" title="Anaconda环境的管理"></a>Anaconda环境的管理</h1><p>创建名为env_name, python版本为3.6的环境</p>
<p><code>conda create -n env_name python=3.6</code></p>
<p>激活env_name</p>
<p><code>conda activate env_name</code></p>
<p>退出环境</p>
<p><code>conda deactivate</code></p>
<p>删除环境</p>
<p><code>conda remove -n env_name --all</code></p>
<p>重命名环境(conda没有重命名的功能, 只能通过克隆 - 删除来实现重命名)</p>
<p><code>conda create --name newname --clone oldname</code> #克隆环境</p>
<p><code>conda remove --name oldname --all</code> #删除旧环境</p>
<p>查看环境列表</p>
<p><code>conda env list</code></p>
<p>清理环境</p>
<p><code>conda clean -p</code>      #删除没用的包</p>
<p><code>conda clean -t</code>      #tar打包</p>
<p><code>conda clean -y -all</code> #删除所有的安装包及cache</p>
<h1 id="package-管理"><a href="#package-管理" class="headerlink" title="package 管理"></a>package 管理</h1><p>有两种方式对python的包进行管理, pip 或 conda</p>
<p>查看所有 package</p>
<p><code>conda list</code> </p>
<p><code>pip list</code></p>
<p>查看某个package的详细信息</p>
<p><code>conda list numpy</code></p>
<p><code>pip show numpy</code></p>
<p>安装 package</p>
<p><code>conda install tensorflow</code> </p>
<p><code>pip install numpy</code></p>
<p>删除 package</p>
<p><code>conda remove numpy</code></p>
<p><code>pip uninstall ethereum</code></p>
<p>更新 package</p>
<p><code>conda update numpy</code></p>
<p><code>pip install --upgrade numpy</code></p>
<h1 id="查看当前源"><a href="#查看当前源" class="headerlink" title="查看当前源"></a>查看当前源</h1><p>conda config –show channels</p>
<h1 id="切换源"><a href="#切换源" class="headerlink" title="切换源"></a>切换源</h1><p>将pip, conda的源切换至清华的(<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">https://mirror.tuna.tsinghua.edu.cn/help/anaconda/</a>):</p>
<p>pip config set global.index-url <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>conda:<br>修改该文件C:/Users/Admin/.condarc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure>

<p><strong>注意: package的安装与更新均可添加特定版本号, pip install numpy==1.17</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>常用激活函数- Sigmoid - Tanh - ReLU - Softmax</title>
    <url>/activationfunction.html</url>
    <content><![CDATA[<h1 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>$S(x)= \frac{1}{1+ e^{-x}}$</p>
<p>$S\prime (x)= \frac{e^{-x}}{(1+e^{-x})^2} = S(x)(1-S(x))$</p>
<span id="more"></span>

<h2 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h2><p><img src="/images/sigmoid.png" alt="sigmoid" title="sigmoid"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">x=np.linspace(-5,5,1000)  </span><br><span class="line">y=[1/(1+np.exp(-i)) for i in x]</span><br><span class="line">y=np.asarray(y)</span><br><span class="line">y1=y*(1-y)</span><br><span class="line">plt.plot(x,y,label=&#x27;sigmoid&#x27;)</span><br><span class="line">plt.plot(x,y1, label=&#x27;Deriv sigmoid&#x27;)</span><br><span class="line"></span><br><span class="line">plt.xlabel(&#x27;x&#x27;)</span><br><span class="line">plt.ylabel(&#x27;f(x)&#x27;)</span><br><span class="line">plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p>
<ol>
<li>求导容易</li>
<li>输出范围有限(0,1), 所以数据在传递的过程中不容易发散.</li>
</ol>
<p>缺点</p>
<ol>
<li>函数饱和使得梯度消失, 从而无法有效更新参数.</li>
<li>函数输出为非零对称的(输出恒大于0), 从而导致梯度在反向传播中全部为正或者全部为负, 使得更新呈现”Z”字型.</li>
<li>复杂的幂运算耗时严重.</li>
</ol>
<h1 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h1><h2 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h2><p>$tanh(x)= \frac{sinh(x)}{cosh(x)} = \frac{e^x - e^{-x}}{e^x + e^{-x}}$</p>
<p>$tanh\prime (x) = 1- tanh^2(x)$</p>
<h2 id="曲线-1"><a href="#曲线-1" class="headerlink" title="曲线"></a>曲线</h2><p><img src="/images/tanh.png" alt="tanh" title="tanh"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">x=np.linspace(-5,5,1000)  </span><br><span class="line">temp1=pow(np.e,x)</span><br><span class="line">temp2=pow(np.e,-x)</span><br><span class="line">y=(temp1-temp2)/(temp1+temp2)</span><br><span class="line">y1=1-y*y</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,label=&#x27;tanh&#x27;)</span><br><span class="line">plt.plot(x,y1, label=&#x27;Deriv tanh&#x27;)</span><br><span class="line">plt.xlabel(&#x27;x&#x27;)</span><br><span class="line">plt.ylabel(&#x27;f(x)&#x27;)</span><br><span class="line">plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure>

<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p>
<ol>
<li>收敛速度快(相对于sigmoid)</li>
<li>不存在非零对称问题</li>
</ol>
<p>缺点</p>
<ol>
<li>函数饱和使得梯度消失, 从而无法有效更新参数.</li>
<li>复杂的幂运算耗时严重.</li>
</ol>
<h1 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h1><p>ReLU(Rectified Linear Unit), 整流线性单位函数, 也称修正线性单元. 通常指以斜坡函数及其变种为代表的非线性函数.</p>
<h2 id="表达式-2"><a href="#表达式-2" class="headerlink" title="表达式"></a>表达式</h2><p>$$f(x) = max(0,x)$$</p>
<!-- $$
f(z) = \left\{ \begin{array}{rcl}
1 & if \quad x>0 \\
0 & otherwise \\
\end{array}\right.
$$ -->

<p>$$<br>f(x)=<br>    \begin{cases}<br>        1 &amp; if \quad x&gt;0 \\<br>        0 &amp; otherwise<br>    \end{cases}<br>$$</p>
<h2 id="曲线-2"><a href="#曲线-2" class="headerlink" title="曲线"></a>曲线</h2><p><img src="/images/ReLU.png" alt="ReLU" title="ReLU"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">x=np.linspace(-5,5,1000)</span><br><span class="line">y=np.zeros_like(x)</span><br><span class="line">y=np.where(x&gt;0, x, y )</span><br><span class="line">y1=np.where(x&gt;0, 1, 0 )</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,label=&#x27;ReLU&#x27;)</span><br><span class="line">plt.plot(x,y1, label=&#x27;Deriv ReLU&#x27;)</span><br><span class="line"></span><br><span class="line">plt.xlabel(&#x27;x&#x27;)</span><br><span class="line">plt.ylabel(&#x27;f(x)&#x27;)</span><br><span class="line">plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure>

<h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p>
<ol>
<li>没有饱和区, 不存在梯度消失问题.</li>
<li>没有复杂的指数运算, 计算简单、效率提高.</li>
<li>实际收敛速度较快, 大约是 Sigmoid/tanh 的 6 倍.</li>
<li>比 Sigmoid 更符合生物学神经激活机制. </li>
</ol>
<p>缺点</p>
<ol>
<li>函数输出为非零对称</li>
<li>Dead ReLU Problem(神经元坏死问题): 某些神经元可能永远不会被激活, 导致相应参数永远不会被更新(当x小于0时, 梯度为0). 产生这种现象的两个原因: 参数初始化问题; learning  rate太高导致在训练过程中参数更新太大. 解决方法: 采用Xavier初始化方法, 以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法. </li>
<li>ReLU不会对数据做幅度压缩, 所以数据的幅度会随着模型层数的增加不断扩张. </li>
</ol>
<h1 id="ReLU的变种版"><a href="#ReLU的变种版" class="headerlink" title="ReLU的变种版"></a>ReLU的变种版</h1><p>之所以叫变种而不是升级, 是因为在某些情况下可以超越ReLU, 但是在有些情况下则无效.</p>
<h2 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h2><p>表达式</p>
<p>$f(x) = max(0.01x,x)$</p>
<p>为了解决Dead ReLU Problem, 将ReLU的前半段设为$0.01x$. </p>
<h2 id="ELU-Exponential-Linear-Units"><a href="#ELU-Exponential-Linear-Units" class="headerlink" title="ELU(Exponential Linear Units)"></a>ELU(Exponential Linear Units)</h2><p>表达式</p>
<!-- $$
f(z) = \left\{ \begin{array}{rcl}
x & if \quad x>0 \\
\alpha(e^x -1) & otherwise \\
\end{array}\right.
$$ -->

<p>$$<br>f(x)=<br>    \begin{cases}<br>        x &amp; if \quad x&gt;0 \\<br>        \alpha(e^x -1) &amp; otherwise<br>    \end{cases}<br>$$</p>
<h1 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h1><p>softmax 函数, 可以称之为归一化指数函数, 其一般应用于多分类问题(输出层激励函数)</p>
<p>它能将一个含人鱼实数的$K$维向量$Z$”压缩”到另一维实向量$\sigma(Z)$中, 使得每个元素的范围都在$(0,1)$之间, 并且所有元素和为1. </p>
<p>$\sigma (z)_j = \frac{e^{z_j}}{\sum _{k=1}^K e^{z_k}} \quad  for j=1,2, \cdots, K$</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="函数饱和"><a href="#函数饱和" class="headerlink" title="函数饱和"></a>函数饱和</h2><p>假设$f(x)$为在实数域上的函数</p>
<ol>
<li><p>当$x$趋近于正无穷, 函数$f(x)$趋近于0, 那么将其称之为右饱和. $\lim \limits_{x \rightarrow +\infty} {f\prime(x) } = 0$</p>
</li>
<li><p>当$x$趋近于负无穷, 函数$f(x)$趋近于0, 那么将其称之为左饱和. $\lim \limits_{x \rightarrow -\infty} {f\prime(x) } = 0$</p>
</li>
<li><p>当一个函数既满足左饱和又满足右饱和的时候我们就称之为饱和, 典型的函数有Sigmoid, Tanh函数.</p>
</li>
<li><p>对于任意的$x$, 如果存在常数$c$, 当$x&gt;c$时, $f(x) \equiv 0$, 则称其为右硬饱和. 相反的, 如果存在常数$c$, 当$x&lt;c$时, $f(x) \equiv 0$, 则称其为左硬饱和. 既满足左硬饱和又满足右硬饱和的我们称这种函数为硬饱和. </p>
</li>
<li><p>对于任意的$x$, 如果存在常数$c$, 当$x&gt;c$时, 恒有$f\prime (x)$趋近于0, 则称其为右软饱和, 相反的, 如果存在常数$c$, 当$x&lt;c$时, 恒有$f\prime (x)$趋近于0,则称其为左软饱和. 既满足左软饱和又满足右软饱和的我们称这种函数为软饱和. </p>
</li>
</ol>
<h2 id="线性关系-函数-amp-非线性关系-函数"><a href="#线性关系-函数-amp-非线性关系-函数" class="headerlink" title="线性关系(函数) &amp; 非线性关系(函数)"></a>线性关系(函数) &amp; 非线性关系(函数)</h2><p>在现代学术界中, 线性关系一词存在2种不同的含义.</p>
<ol>
<li><p>若某数学函数或数量关系的函数图形呈现为一条直线或线段, 那么这种关系就是一种线性的关系.<br> 定义: $f(x)$是个只拥有一个变数的一阶多项式函数, 即是可以表示为 $ f(x)=kx+b $的形式(其中$k,b$为常数).</p>
</li>
<li><p>在代数学和数学分析学中, 如果一种运算同时满足特定的”加性”和”齐性”, 则称这种运算是线性的.<br> 定义: $f(x)$具有两个性质: 可加性 $f(x+t) = f(x) + f(t)$, 一次齐次性 $f(mx) = mf(x)$</p>
</li>
</ol>
<p>非线性关系(函数)是指除了线性关系(函数)以为的其他函数, 指数函数, 对数函数, 幂函数, 多项式函数等. </p>
]]></content>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透工具 - FRP</title>
    <url>/Frp.html</url>
    <content><![CDATA[<h1 id="为什么要进行内网穿透"><a href="#为什么要进行内网穿透" class="headerlink" title="为什么要进行内网穿透"></a>为什么要进行内网穿透</h1><p>最主要的原因是可以在公网访问自己的私有设备(远程桌面, 文件共享等). </p>
<p>常用的内网渗透工具有 <a href="https://www.teamviewer.cn/cn/">Teamview</a>, <a href="https://sunlogin.oray.com/personal/">向日葵远程控制</a>, <a href="https://pgy.oray.com/">蒲公英VPN</a></p>
<p>以上三种工具免费版都具有众多问题, 因此本文介绍一种免费的内网穿透工具FRP(Fast Reverse Proxy)</p>
<span id="more"></span>
<h1 id="何为FRP"><a href="#何为FRP" class="headerlink" title="何为FRP"></a>何为FRP</h1><p><a href="https://github.com/fatedier/frp">FRP(Fast Reverse Proxy)</a>是一个开源反向代理软件, 其体积轻量但是功能强大, 支持tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。</p>
<h1 id="搭建FRP"><a href="#搭建FRP" class="headerlink" title="搭建FRP"></a>搭建FRP</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>拥有一台具有公网IP的VPS</p>
<p> 可以申请<a href="https://www.aliyun.com/acts/hotsale?userCode=ow1txsbr">阿里云</a>, 腾讯云, 华为云等服务器, 也可以申请亚<a href="https://aws.amazon.com/cn/">马逊云</a>(此服务器免费试用一年).</p>
</li>
<li><p>FRP client and server</p>
<p> 在<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a> 下载相应的系统和版本的FRP.</p>
</li>
</ol>
<h2 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>配置文件为frps.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure>

<p>启动服务<br><code>./frps -c ./frps.ini</code></p>
<p>后台启动<br><code>nohup ./frps -c ./frps.ini &gt; frpss.log 2&gt;&amp;1 &amp;</code></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>配置文件为frpc.ini, 其中x.x.x.x为服务端公网的IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br></pre></td></tr></table></figure>

<p>启动服务<br><code>./frpc -c ./frpc.ini</code></p>
<p>后台启动<br><code>nohup ./frpc -c ./frpc.ini &gt; frpcc.log 2&gt;&amp;1 &amp;</code></p>
<h3 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h3><p>通过 ssh 访问内网机器, 假设用户名为 test：</p>
<p><code>ssh -oPort=6000 test@x.x.x.x</code></p>
<h1 id="高阶配置"><a href="#高阶配置" class="headerlink" title="高阶配置"></a>高阶配置</h1><h2 id="自定义域名访问"><a href="#自定义域名访问" class="headerlink" title="自定义域名访问"></a>自定义域名访问</h2><h2 id="转发-DNS-查询请求"><a href="#转发-DNS-查询请求" class="headerlink" title="转发 DNS 查询请求"></a>转发 DNS 查询请求</h2><h2 id="转发-Unix-域套接字"><a href="#转发-Unix-域套接字" class="headerlink" title="转发 Unix 域套接字"></a>转发 Unix 域套接字</h2><h2 id="对外提供简单的文件访问服务"><a href="#对外提供简单的文件访问服务" class="headerlink" title="对外提供简单的文件访问服务"></a>对外提供简单的文件访问服务</h2><h2 id="为本地-HTTP-服务启用-HTTPS"><a href="#为本地-HTTP-服务启用-HTTPS" class="headerlink" title="为本地 HTTP 服务启用 HTTPS"></a>为本地 HTTP 服务启用 HTTPS</h2><h2 id="安全地暴露内网服务"><a href="#安全地暴露内网服务" class="headerlink" title="安全地暴露内网服务"></a>安全地暴露内网服务</h2><h2 id="点对点内网穿透"><a href="#点对点内网穿透" class="headerlink" title="点对点内网穿透"></a>点对点内网穿透</h2>]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Python读写Excel</title>
    <url>/pythonexcel.html</url>
    <content><![CDATA[<p>在日常生活中时长面临操作大量Excel文件的情况, 如何有效的利用Python脚本来实现复杂的操作呢? 本文旨在介绍python中操作Excel文件的几个包: xlrd(读), xlwt(写), openpyxl(读,写), 以及pandas.</p>
<blockquote>
<p>注意: 利用xlrd和xlwt操作Excel时, 只有读和写, 没有修改这一选项, 如果想要修改某个单元格, 需要将原有数据读出, 修改过后, 重新写入新的Excel文件. </p>
</blockquote>
<blockquote>
<p>xlrd 适用于任何版本的Excel文件, Python 2.7, 3.4+.</p>
</blockquote>
<blockquote>
<p>xlwt 适用于 MS Excel 97/2000/XP/2003 XLS files, Python 2.6, 2.7, 3.3+ (xlwt无法将文件保存为.xlsx文件, 且不能写入超过65535行,256列的数据).</p>
</blockquote>
<blockquote>
<p>openpyxl 适用于Excel 2010 xlsx/xlsm/xltx/xltm, Python &gt;=3.6.</p>
</blockquote>
<blockquote>
<p>pandas 是进行数据分析和处理的常用包, 处理Excel只是其功能的很小一部分. 在利用其处理Excel时, 其依赖xlrd包, 需要安装xlrd后, 方可利用pandas 处理Excel. pandas读取Excel并处理的本质是将Excel数据读至DataFrame 进行操作, 本文所涉及的均是DataFrame 的常用操作.</p>
</blockquote>
<span id="more"></span>

<h1 id="Excel中的基本概念"><a href="#Excel中的基本概念" class="headerlink" title="Excel中的基本概念"></a>Excel中的基本概念</h1><p>工作簿: Excel 文件的另一种名称.</p>
<p>工作表: 又叫Worksheet, 一个工作簿可以包含多个工作表. 如下图中的 “微信”, “头条” 和”sheet2”均是一个Worksheet, 默认的Worksheet为Sheet1.</p>
<p>单元格: Worksheet的组成部分, Excel中存储数据的最小单元.</p>
<p>单元格地址: 单元格在工作表上的地址, 由字母和数字构成, 下图单元格地址为D28.</p>
<p><img src="/images/excel.png" alt="Excel" title="Excel基本概念"></p>
<h1 id="xlrd-读Excel"><a href="#xlrd-读Excel" class="headerlink" title="xlrd-读Excel"></a>xlrd-读Excel</h1><p>导入相关包 </p>
<pre><code>import xlrd
</code></pre>
<p>打开工作簿(xlrd只能以只读形式打开Excel文件)</p>
<pre><code>data=xlrd.open_workbook(filename)
</code></pre>
<p>查看所有工作表名称</p>
<pre><code>data.sheet_names()
</code></pre>
<p>选择某个工作表</p>
<pre><code>#获取第一个工作表
table=data.sheets()[0]

#通过索引获取第一个工作表
table=data.sheet_by_index(0)

#通过表名称选择工作表
table=data.sheet_by_name(u&#39;微信&#39;)
</code></pre>
<p>获取当前工作表的行数和列数</p>
<pre><code>nrows=table.nrows
ncols=table.ncols
</code></pre>
<p>获取某行和某列的值</p>
<pre><code>table.row_values(number)
table.col_values(number)
</code></pre>
<p>查看某个单元格的值</p>
<pre><code>#直接定位
cell=table.cell(0,0).value

#通过行来检索
cell=table.row(0)[0].value

#通过列来检索
cell=table.col(0)[0].value
</code></pre>
<p>求取上面图片中文章总数之和(共计144)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import xlrd</span><br><span class="line">filename=&#x27;example.xlsx&#x27;</span><br><span class="line">data=xlrd.open_workbook(filename)</span><br><span class="line">table=data.sheet_by_name(u&#x27;微信&#x27;)</span><br><span class="line">total=0</span><br><span class="line">for value in table.col_values(0)[1:]:</span><br><span class="line">    total+=int(value)</span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure>

<h1 id="xlwt-写Excel"><a href="#xlwt-写Excel" class="headerlink" title="xlwt-写Excel"></a>xlwt-写Excel</h1><p>导入相关包 </p>
<pre><code>import xlwt
</code></pre>
<p>新建Excel文件</p>
<pre><code>data=xlwt.Workbook()
</code></pre>
<p>新建工作表</p>
<pre><code>table=data.add_sheet(&#39;sheet1&#39;)
</code></pre>
<p>写入数据到单元格</p>
<pre><code>table.write(0,0,u&#39;文章总数&#39;)
</code></pre>
<blockquote>
<p>注意: 如果对同一个单元格重复操作, 会导致异常”Exception: Attempt to overwrite cell:”, 如果想对单元格重复操纵, 需要在新建工作表时指定<code>cell_overwrite_ok=True</code></p>
</blockquote>
<pre><code>table=data.add_sheet(&#39;sheet1&#39;,cell_overwrite_ok=True)
</code></pre>
<p>设置单元格样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#初始化样式</span><br><span class="line">style=xlwt.XFStyle()</span><br><span class="line"></span><br><span class="line">#创建字体</span><br><span class="line">font=xlwt.Font()</span><br><span class="line"></span><br><span class="line">#指定字体</span><br><span class="line">font.name=&#x27;Times New Roman&#x27;</span><br><span class="line"></span><br><span class="line">#指定字号为11, 其中20为单位</span><br><span class="line">font.height=11 * 20</span><br><span class="line"></span><br><span class="line">#指定颜色0-63, 0 = Black, 1 = White, 2 = Red, 3 = Green, 4 = Blue, 5 = Yellow, 6 = Magenta, 7 = Cyan, 16 = Maroon, 17 = Dark Green, 18 = Dark Blue, 19 = Dark Yellow , almost brown), 20 = Dark Magenta, 21 = Teal, 22 = Light Gray, 23 = Dark Gray, the list goes on...</span><br><span class="line"></span><br><span class="line">font.colour_index = 0</span><br><span class="line"></span><br><span class="line">#字体加粗, 下划线 underline, 斜体 italic</span><br><span class="line">font.bold=True</span><br><span class="line"></span><br><span class="line">#将该font设定为style的字体</span><br><span class="line">style.font=font</span><br><span class="line"></span><br><span class="line">#创建背景色图案</span><br><span class="line">pattern = xlwt.Pattern()</span><br><span class="line"></span><br><span class="line">#指定图案, 图案有[NO_PATTERN, SOLID_PATTERN, or 0x00 through 0x12]</span><br><span class="line">pattern.pattern = xlwt.Pattern.SOLID_PATTERN </span><br><span class="line"></span><br><span class="line">#指定图案颜色</span><br><span class="line">pattern.pattern_fore_colour = 5</span><br><span class="line"></span><br><span class="line">#将该pattern设定为style的pattern</span><br><span class="line">style.pattern = pattern # Add Pattern to Style</span><br><span class="line"></span><br><span class="line">#写入到文件时使用该样式</span><br><span class="line">table.write(0,2,&#x27;test 哈哈哈&#x27;,style)</span><br></pre></td></tr></table></figure>




<p>完整程序代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import xlwt</span><br><span class="line"></span><br><span class="line">data=xlwt.Workbook()</span><br><span class="line">table=data.add_sheet(&#x27;sheet1&#x27;,cell_overwrite_ok=True)</span><br><span class="line">#初始化样式</span><br><span class="line">style=xlwt.XFStyle()</span><br><span class="line"></span><br><span class="line">#创建字体</span><br><span class="line">font=xlwt.Font()</span><br><span class="line"></span><br><span class="line">#指定字体</span><br><span class="line">font.name=&#x27;Times New Roman&#x27;</span><br><span class="line"></span><br><span class="line">#指定字号为11, 其中20为单位</span><br><span class="line">font.height=11 * 20</span><br><span class="line"></span><br><span class="line">#指定颜色0-63, 0 = Black, 1 = White, 2 = Red, 3 = Green, 4 = Blue, 5 = Yellow, 6 = Magenta, 7 = Cyan, 16 = Maroon, 17 = Dark Green, 18 = Dark Blue, 19 = Dark Yellow , almost brown), 20 = Dark Magenta, 21 = Teal, 22 = Light Gray, 23 = Dark Gray, the list goes on...</span><br><span class="line"></span><br><span class="line">font.colour_index = 0</span><br><span class="line"></span><br><span class="line">#字体加粗, 下划线 underline, 斜体 italic</span><br><span class="line">font.bold=True</span><br><span class="line"></span><br><span class="line">#将该font设定为style的字体</span><br><span class="line">style.font=font</span><br><span class="line"></span><br><span class="line">#创建背景色图案</span><br><span class="line">pattern = xlwt.Pattern()</span><br><span class="line"></span><br><span class="line">#指定图案, 图案有[NO_PATTERN, SOLID_PATTERN, or 0x00 through 0x12]</span><br><span class="line">pattern.pattern = xlwt.Pattern.SOLID_PATTERN </span><br><span class="line"></span><br><span class="line">#指定图案颜色</span><br><span class="line">pattern.pattern_fore_colour = 5</span><br><span class="line"></span><br><span class="line">#将该pattern设定为style的pattern</span><br><span class="line">style.pattern = pattern # Add Pattern to Style</span><br><span class="line"></span><br><span class="line">#写入到文件时使用该样式</span><br><span class="line">table.write(0,2,&#x27;test 哈哈哈&#x27;,style)</span><br><span class="line"></span><br><span class="line">table.write(0,0,u&#x27;文章总数&#x27;)</span><br><span class="line">total=144</span><br><span class="line">table.write(0,1,total)</span><br><span class="line">data.save(&#x27;xxx.xls&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="openpyxl-读写Excel"><a href="#openpyxl-读写Excel" class="headerlink" title="openpyxl - 读写Excel"></a>openpyxl - 读写Excel</h1><p>导入相关包 </p>
<pre><code>from openpyxl import load_workbook
from openpyxl import Workbook
</code></pre>
<p>加载(创建)工作簿</p>
<pre><code>wb = load_workbook(&#39;sample.xlsx&#39;) #加载
wb = Workbook() #创建
</code></pre>
<p>查看所有工作表</p>
<pre><code>wb.sheetnames
wb.get_sheet_names()
</code></pre>
<p>激活活动的工作表</p>
<pre><code>#默认激活最后创建的工作表
ws = wb.active
</code></pre>
<p>激活任意工作表</p>
<pre><code>ws=wb.get_sheet_by_name(&quot;Sheet name&quot;)
</code></pre>
<p>查看工作表行列数目</p>
<pre><code>ws.max_row
ws.max_column
</code></pre>
<p>查看单元格数据</p>
<pre><code># 使用WorkSheet的Cell方法
cell = ws.cell(&#39;A1&#39;)
cell = ws.cell(row=1, column=1)
# 通过坐标获取Cell
cell = ws[&#39;A1&#39;]
# 获取多个
cell = ws[&#39;A1:E5&#39;]  # 返回多行数据,类型为tuple
</code></pre>
<p>查看某行(列)数据<br>    #查看第一列数据, 其中min_row 最小值为1, 当min_row=0时, 结果与min_row=1一致. min_col=1, max_col=1表示第一列(Excel中计数从1开始)<br>    for data in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=1, max_col=1):<br>        print(data[0].value)</p>
<pre><code>#查看第二行数据,  min_row=2, max_row=2 表示第二行
for data in ws.iter_cols(min_col=1, max_col=ws.max_column, min_row=2, max_row=2): 
    print(data[0].value)
</code></pre>
<p>修改(赋值)单元格数据</p>
<pre><code># 使用WorkSheet的Cell方法
ws.cell(row=1, column=1, value=10)
ws[&#39;A1&#39;]=10

# 设置Cell对象value属性
cell = ws.cell(&#39;A1&#39;)
cell.value = 100

#在最后一行追加一行
ws.append([1, 2, 3])

#修改完毕后, 需要保存
wb.save(&#39;filename.xlsx&#39;)
</code></pre>
<p>设置单元格样式</p>
<pre><code>#导入字体颜色包
from openpyxl.styles import Font, colors

#创建样式, 字号15, 字体Times New Roman,  颜色红色, 斜体, 加粗, 下划线&#123;&#39;double&#39;, &#39;single&#39;, &#39;doubleAccounting&#39;, &#39;singleAccounting&#39;&#125; #这里下划线样式较多, 是因为 openpyxl支持Excel的最新版本, 与xlwt不同
ft = Font(size=15, name=&#39;Times New Roman&#39;,color=colors.RED, italic=True, bold=True, underline=&#39;double&#39;)

#给单元格赋值样式
ws[&#39;A1&#39;]=10
ws[&#39;A1&#39;].font=ft

#给单独某行(列)单元格赋值样式(对已经有数据的单元格无效, 打开Excel自行插入有效)
col = ws.column_dimensions[&#39;A&#39;]
col.font = Font(bold=True)
row = ws.row_dimensions[1]
row.font = Font(underline=&quot;single&quot;)
</code></pre>
<blockquote>
<p>修改样式切勿直接赋值, 需要重新创建Font实例, 方能修改成功, 也可通过复制其他样式实例进行修改</p>
</blockquote>
<pre><code># 错误操作
ws[&#39;A1&#39;].font.size=20

# 正确操作, 创建实例修改
ws[&#39;A1&#39;].font=Font(size=20)

# 拷贝font, 并赋值
ftcopy=ft.copy(size=20)
ws[&#39;A1&#39;].font=ftcopy
</code></pre>
<p>求取上面图片中文章总数之和(共计144), 并将结果写入该文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from openpyxl import load_workbook</span><br><span class="line">from openpyxl.styles import Font, colors</span><br><span class="line">filename=&#x27;example.xlsx&#x27;</span><br><span class="line"></span><br><span class="line">wb = load_workbook(filename)</span><br><span class="line"></span><br><span class="line">ws=wb.get_sheet_by_name(u&#x27;微信&#x27;)</span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line">for data in ws.iter_rows(min_row=2, max_row=ws.max_row, min_col=1, max_col=1): </span><br><span class="line">    total+=int(data[0].value)</span><br><span class="line">print(total)</span><br><span class="line"></span><br><span class="line">ft = Font(size=15, name=&#x27;Times New Roman&#x27;,color=colors.RED, italic=True, bold=True, underline=&#x27;double&#x27;)</span><br><span class="line">ws[&#x27;A20&#x27;]=total</span><br><span class="line">ws[&#x27;A20&#x27;].font=ft</span><br><span class="line"></span><br><span class="line">ws.append([&#x27;文章总计&#x27;,total])</span><br><span class="line"></span><br><span class="line">wb.save(filename)</span><br></pre></td></tr></table></figure>



<h1 id="pandas-读写Excel"><a href="#pandas-读写Excel" class="headerlink" title="pandas - 读写Excel"></a>pandas - 读写Excel</h1><blockquote>
<p>注意, 在pandas中 数字0,1,…既可以表示索引, 也可以表示表头项. 在指定表头项且表头项不为数字时, 数字0,1表示索引, 否则表示表头项.</p>
</blockquote>
<p>索引和表头项对比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">filename=&#x27;example.xlsx&#x27;</span><br><span class="line">df=pd.ExcelFile(filename)</span><br><span class="line">df =df.parse(&#x27;微信&#x27;)</span><br><span class="line">print(df)</span><br><span class="line">data=df.ix[0].values</span><br><span class="line">print(&#x27;-----------&#x27;)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p><img src="/images/pandas-excel-head.png" alt="表头项" title="表头项"><br><img src="/images/pandas-excel-index.png" alt="索引" title="索引"></p>
<p>导入相关包 </p>
<pre><code>import  pandas  as pd
</code></pre>
<p>打开工作簿(read_excel为打开Excel函数, ExcelFile为一个类, 其功能能为强大)</p>
<pre><code>#默认读取Excel的第一个工作表
df=pd.read_excel(filename)

#通过sheet_name指定工作表
df=pd.read_excel(filename,sheet_name=&#39;微信&#39;)

#通过索引读取指定工作表, 索引顺序由左到右0, 1, ...
df=pd.read_excel(filename,sheet_name=0)

#混合方式读取多个工作表
df=pd.read_excel(filename,sheet_name=[&#39;微信&#39;,2])

#使用ExcelFile打开工作表, 同样适用索引, 或者混合模式
df=pd.ExcelFile(filename).parse(&#39;微信&#39;)
</code></pre>
<p>查看所有工作表名称</p>
<pre><code>df=pd.ExcelFile(filename)
df.sheet_names

#选择工作表
df=df.parse(&#39;微信&#39;)
</code></pre>
<p>读取指定行列</p>
<pre><code>#0表示第一行或 项目为0的那行, 
data=df.ix[0].values

#读取多行, 需要传入一个list
data=df.ix[[1,2]].values

#读取指定列
data=df[&#39;文章总数&#39;].values

#读取多列
data=df[[&#39;文章总数&#39;, &#39;文章总增量&#39;]].values

#读取指定单元格
data=df.ix[1,2]
data=df[&#39;文章总数&#39;][0]
</code></pre>
<p>求取上面图片中文章总数之和, 并存入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import  pandas  as pd</span><br><span class="line">filename=&#x27;example.xlsx&#x27;</span><br><span class="line">df=pd.ExcelFile(filename)</span><br><span class="line">df =df.parse(&#x27;微信&#x27;)</span><br><span class="line">data=sum(df[&#x27;文章总数&#x27;].values)</span><br><span class="line">xx=[&#x27;&#x27; for i in range(df.shape[1])]</span><br><span class="line">xx[1]=data</span><br><span class="line">xx[0]=&#x27;文章总数&#x27;</span><br><span class="line">df.loc[df.shape[0]]=xx</span><br><span class="line"></span><br><span class="line">df.to_excel(&#x27;new.xlsx&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>信息熵 - 条件熵 - 交叉熵</title>
    <url>/crossentropy.html</url>
    <content><![CDATA[<p>信息社会, 我们在日常生活中一直谈论信息, 但是信息这个概念有些抽象. 有时候说信息多, 或者信息少, 但是很难说清楚到底是多少. 比如一本50多万字的中文书&lt;史记&gt;到底有多少信息量, 很难进行定量的表示. 直到1948年, 香农(Claude Shannon)提出了信息熵的概念, 才解决了信息度量问题.</p>
<span id="more"></span>

<h1 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h1><p>一条信息的信息量和它的不确定性有着直接关系. 举个例子, 一个有5个字的句子(你吃饭了吗?)和有17个字的句子(我刚在市中心的CBD内吃完, 吃的牛排.)包含的信息量正常情况下是不一样的, 包括17个字的句子所包含的信息量应该大于5个字的. </p>
<p>如何对信息进行量化呢? 再来举个例子, 2018年的世界杯, 大家都很关心谁是冠军. 假如我错过了看世界杯, 赛后问一个知道比赛结果的观众”哪只球队是冠军”? 他不愿意直接告诉我, 而是让我去猜, 并且猜一次收费1元. 那么我需要猜测多少次才能知道谁是冠军呢? 我可以把球队编为1-32号, 然后采用二分法进行猜测, 直至猜到结果. 这样我只需要五次就可以知道谁是冠军. 所以, 谁是世界杯冠军这条消息的信息量只值5元钱.</p>
<p>香农采用”比特(Bit)”来度量信息量. 上面的例子中, 这条消息的信息量是5比特. ($log_2^32 =5$) 世界杯每只球队的夺冠概率是不一致的, 我们在进行猜测时需要有侧重点的进行猜测, 因此”谁是世界杯冠军”的信息量比5比特少. 香农指出, 它的准确信息量应该是<br>$H=-(p_1 \cdot log p_1 + p_2 \cdot log p_2 + \cdots + p_{32} \cdot log p_{32} )$ 其中, $p_1, p_2, \cdots , p_{32}$分别是这32支球队夺冠的概率. 香农把$H$称之为信息熵(Entropy), 单位比特. 对于任意一个随机变量X(比如得冠军的球队), 它的熵为</p>
<p>$H(X) = - \sum _{x \in X} P(x) logP(x)$</p>
<p>变量的不确定性越大, 熵也就越大.</p>
<h1 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h1><p>假定X和Y是两个随机变量, X是我们需要了解的. 假定我们知道X的随机分布P(X), 那么也就知道了X的熵</p>
<p>$H(X) = -\sum _{x \in X} P(x) \cdot log P(x)$</p>
<p>现在假定我们还知道Y的一些情况, 包括它和X一起出现的概率(在数学上称之为联合概率分布), 以及在Y取不同值的前提下X的概率分布(在数学上称之为条件概率分布). 那么定义在Y条件下X的条件熵为</p>
<p>$H(X|Y) = - \sum _{x \in X, y\in Y} P(x,y) log P(x|y)$</p>
<h1 id="交叉熵-相对熵-Kullback-Leibler-Divergence"><a href="#交叉熵-相对熵-Kullback-Leibler-Divergence" class="headerlink" title="交叉熵(相对熵) (Kullback-Leibler Divergence)"></a>交叉熵(相对熵) (Kullback-Leibler Divergence)</h1><p>交叉熵可以用来衡量相关性, 它用来衡量两个取值为正数的函数的相似性, 定义如下</p>
<p>$KL(f(x) || g(x)) = \sum _{x\in X} f(x) \cdot log \frac{f(x)}{g(x)}$</p>
<p>我们不需要关注公式本身, 只需要记住下面三条结论就可以:</p>
<ol>
<li>对于两个完全相同的函数, 它们的交叉熵为0.</li>
<li>交叉熵越大, 两个函数差异越大; 反之, 交叉熵越小, 两个函数差异越小.</li>
<li>对于概率分布或者概率密度函数, 如果取值均大于0, 交叉熵可以度量两个随机分布的差异性.</li>
</ol>
<h2 id="注意-本文中的对数均是以2为底-log-log-2"><a href="#注意-本文中的对数均是以2为底-log-log-2" class="headerlink" title="注意: 本文中的对数均是以2为底. $log==log_2$"></a>注意: 本文中的对数均是以2为底. $log==log_2$</h2>]]></content>
      <tags>
        <tag>数学概念</tag>
      </tags>
  </entry>
  <entry>
    <title>随机数</title>
    <url>/pythonrandom.html</url>
    <content><![CDATA[<h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>随机数在不同的范畴有着不同的定义, 其分为密码学范畴的随机数和密码学外的随机数. </p>
<h2 id="密码学范畴的随机数"><a href="#密码学范畴的随机数" class="headerlink" title="密码学范畴的随机数"></a>密码学范畴的随机数</h2><p>根据密码学原理, 随机数的随机性检验分为三个标准</p>
<span id="more"></span>


<ol>
<li>统计学伪随机性. 统计学伪随机性指的是在给定的随机比特流样本中, 1的数量大致等于0的数量, 同理, “10” “01” “00” “11” 四者数量大致相等. 类似的标准被称为统计学随机性. 满足这类要求的数字在人类 “一眼看上去” 是随机的. </li>
</ol>
<ol start="2">
<li><p>密码学安全伪随机性. 其定义为, 给定随机样本的一部分和随机算法, 不能有效的演算出随机样本的剩余部分. </p>
</li>
<li><p>真随机性. 其定义为随机样本不可重现. 实际上衹要给定边界条件, 真随机数并不存在, 可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机当地的本底辐射波动值）, 可以认为用这个方法演算出来了真随机数. 但实际上, 这也只是非常接近真随机数的伪随机数, 一般认为, 无论是本地辐射、物理噪音、抛硬币……等都是可被观察了解的, 任何基于经典力学产生的随机数, 都只是伪随机数. </p>
</li>
</ol>
<p>相应的, 随机数也分为三类</p>
<ol>
<li>伪随机数: 满足第一个条件的随机数. </li>
<li>密码学安全的伪随机数: 同时满足前两个条件的随机数. 可以通过密码学安全伪随机数生成器计算得出. </li>
<li>真随机数: 同时满足三个条件的随机数. </li>
</ol>
<h2 id="密码学外的随机数"><a href="#密码学外的随机数" class="headerlink" title="密码学外的随机数"></a>密码学外的随机数</h2><p>随机数是专门的随机试验的结果. </p>
<p>在统计学的不同技术中需要使用随机数, 比如在从统计总体中抽取有代表性的样本的时候, 或者在将实验动物分配到不同的试验组的过程中, 或者在进行蒙特卡罗模拟法计算的时候等等. </p>
<p>产生随机数有多种不同的方法. 这些方法被称为随机数生成器. 随机数最重要的特性是它在产生时后面的那个数与前面的那个数毫无关系. </p>
<p>真正的随机数是使用物理现象产生的: 比如掷钱币、骰子、转轮、使用电子组件的噪音、核裂变等等. 这样的随机数生成器叫做物理性随机数生成器, 它们的缺点是技术要求比较高. </p>
<p>在实际应用中往往使用伪随机数就足够了. 这些数列是“似乎”随机的数, 实际上它们是通过一个固定的、可以重复的计算方法产生的. 它们不真正地随机, 因为它们实际上是可以计算出来的, 但是它们具有类似于随机数的统计特征. 这样的生成器叫做伪随机数生成器. </p>
<h1 id="Python中的-伪-随机数"><a href="#Python中的-伪-随机数" class="headerlink" title="Python中的(伪)随机数"></a>Python中的(伪)随机数</h1><p>python中常用的随机数的包有 <code>random</code>, <code>np.random</code>, 其生成随机数的原理均为<a href="https://zh.wikipedia.org/wiki/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95">梅森旋转算法(Mersenne twister)</a>. 梅森旋转算法(Mersenne twister)是一个伪随机数发生算法. 由松本真和西村拓士[1]在1997年开发, 基于有限二进制字段上的矩阵线性递归$F_2$, 可以快速产生高质量的伪随机数.</p>
<p>在调用random包生成随机数时, 都会默认产生一个随机数种子seed, 如果指定该seed, 那么每次生成的随机数将一致.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">random.seed(1)</span><br><span class="line">for i in range(5):</span><br><span class="line">    print(random.randint(0,9),end=&quot;&quot;)</span><br><span class="line">&gt;&gt;&gt;29141</span><br></pre></td></tr></table></figure>

<p>在进行一些复杂的需要产生随机数的试验时, 初始化一个特定的种子, 那么每次运行程序得到的结果是一致的.</p>
<p>[1]Makoto Matsumoto, Takuji Nishimura. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator. ACM Transactions on Modeling and Computer Simulation (TOMACS). 1998-01-01, 8 (1): 3–30</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名函数 lambda</title>
    <url>/Lambda.html</url>
    <content><![CDATA[<h1 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h1><p>lambda也被称为匿名函数, 既没有确定的函数名称. 在有些时候, 不需要显示定义函数, 直接传入具体的操作则可以使用lambda更方便.</p>
<h1 id="lambda-语法"><a href="#lambda-语法" class="headerlink" title="lambda 语法"></a>lambda 语法</h1><p><code>lambda argument_list : expression</code> #argument_list为参数列表, 其有多种形式, expression则为表达式, 表示我们需要执行的操作</p>
<p><code>lambda x,y: x+y</code> #该语句表示输入两个参数x,y, 并返回x+y的值</p>
<h1 id="常用情形"><a href="#常用情形" class="headerlink" title="常用情形"></a>常用情形</h1><span id="more"></span>


<p>lambda经常与其他函数联合使用, 下面进行分别阐述</p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter(function, iterable)</code> #函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个迭代器对象, 如果要转换为列表, 可以使用 list() 来转换.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 过滤出列表中的所有奇数</span><br><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line">newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(list(newlist))</span><br><span class="line">&gt;&gt;&gt; [1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<p>转换为filter + lambda表达式可以写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newlist=filter(lambda n: n if n % 2 ==1 else None, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(list(newlist))</span><br><span class="line">&gt;&gt;&gt; [1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map(function, iterable, ...)</code> #根据提供的函数对指定序列做映射, 生成一个新的迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def square(x): # 计算平方数</span><br><span class="line">    return x ** 2</span><br><span class="line">newlist=map(square, [1,2,3,4,5])  # 计算列表各个元素的平方</span><br><span class="line">print(list(newlist))</span><br><span class="line">&gt;&gt;&gt;[1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line">newlist=map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数</span><br><span class="line">print(list(newlist))</span><br><span class="line">&gt;&gt;&gt;[1, 4, 9, 16, 25]</span><br><span class="line"> </span><br><span class="line"># 提供了两个列表，对相同位置的列表数据进行相加</span><br><span class="line">newlist=map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])</span><br><span class="line">print(list(newlist))</span><br><span class="line">&gt;&gt;&gt; [3, 7, 11, 15, 19]</span><br></pre></td></tr></table></figure>


<h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p><code>sorted(iterable, key=None, reverse=False)</code> #函数对所有可迭代的对象进行排序操作.(所有可迭代的对象为重点, 该函数与sort的区别是, sort是list上的方法, 而sorted可以对所有可迭代对象进行排序操作, list dict tuple等).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sorted([5, 2, 3, 1, 4])</span><br><span class="line">&gt;&gt;&gt;[1, 2, 3, 4, 5]  # 默认为升序</span><br><span class="line"></span><br><span class="line">sorted((5, 2, 3, 1, 4))</span><br><span class="line">&gt;&gt;&gt;[1, 2, 3, 4, 5]  # 默认为升序</span><br><span class="line"></span><br><span class="line">sorted(&#123;1: &#x27;D&#x27;, 2: &#x27;B&#x27;, 3: &#x27;B&#x27;, 4: &#x27;E&#x27;, 5: &#x27;A&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt;[1, 2, 3, 4, 5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当传入参数为复杂的组合对象时, 如果需要进行更复杂的排序操作, 则可以借助lambda实现复杂的排序操纵. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#有一个学生成绩字典, 每一项中有五门成绩, 分别是语 数 外 物理 和化学 </span><br><span class="line">students=&#123;&#x27;Zhang&#x27;:[60,70,65,75,83],&#x27;Wang&#x27;:[70,66,80,90,73],&#x27;Li&#x27;:[66,79,80,90,59],&#x27;Zhao&#x27;:[80,90,88,60,75]&#125;</span><br><span class="line"></span><br><span class="line">按照外语成绩进行降序排列</span><br><span class="line">sorted(students.items(), key= lambda x: x[1][2],reverse=True)</span><br><span class="line">&gt;&gt;&gt;[(&#x27;Zhao&#x27;, [80, 90, 88, 60, 75]), (&#x27;Wang&#x27;, [70, 66, 80, 90, 73]), (&#x27;Li&#x27;, [66, 79, 80, 90, 59]), (&#x27;Zhang&#x27;, [60, 70, 65, 75, 83])]</span><br><span class="line"></span><br><span class="line">在外语成绩相同的情况下, 数学成绩谁高, 谁在前</span><br><span class="line">sorted(students.items(), key= lambda x: [x[1][2],x[1][1]],reverse=True)</span><br><span class="line">&gt;&gt;&gt;[(&#x27;Zhao&#x27;, [80, 90, 88, 60, 75]), (&#x27;Li&#x27;, [66, 79, 80, 90, 59]), (&#x27;Wang&#x27;, [70, 66, 80, 90, 73]), (&#x27;Zhang&#x27;, [60, 70, 65, 75, 83])]</span><br><span class="line"></span><br><span class="line">按照总成绩排序</span><br><span class="line">sorted(students.items(), key= lambda x: sum(x[1]),reverse=True)</span><br><span class="line">&gt;&gt;&gt;[(&#x27;Zhao&#x27;, [80, 90, 88, 60, 75]), (&#x27;Wang&#x27;, [70, 66, 80, 90, 73]), (&#x27;Li&#x27;, [66, 79, 80, 90, 59]), (&#x27;Zhang&#x27;, [60, 70, 65, 75, 83])]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github搭建blog</title>
    <url>/HexoBlog.html</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><a href="http://www.git-scm.com/download/">下载Git</a> ,选择自己合适的版本。我是在windows下搭建的，所以我选的是windows<br>安装完成后，在开始菜单里找到”Git”-&gt;”Git Bash”，弹出命令行窗口，就说明安装成功<br><img src="/images/git-bash.png" alt="Git Bash" title="Git Bash"></p>
<span id="more"></span>
<h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><p>设置用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。<br>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
</blockquote>
<p>查看密钥<br><code>cd ~/.ssh</code>如果没有，则不会有此文件夹，有的话则备份删除</p>
<p>生成密钥<br><code>$ ssh-keygen -t rsa -C "<a href="mailto:&#x65;&#x6d;&#97;&#x69;&#108;&#64;&#x65;&#x78;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;">&#x65;&#x6d;&#97;&#x69;&#108;&#64;&#x65;&#x78;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;</a>" </code> 按3个回车，密码为空。<br>最后得到了两个文件：id_rsa和id_rsa.pub</p>
<p>添加密钥到ssh-agent(如果报错, 尝试执行<code> eval `ssh-agent -s`<code> 后, 再执行下面的命令)<br><code> $ ssh-add ~/.ssh/id_rsa</code></p>
<p>登录Github，添加ssh<br>把id_rsa.pub文件里的内容复制到Github中的ssh keys中<br><img src="/images/github-ssh.png" alt="Github ssh" title="Github ssh"></p>
<p>测试<br><code>$ ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#111;&#109;</a></code>选择yes，就可以看到你的用户名，则说明配置成功<br><img src="/images/git-ssh-success.png" alt="git-ssh-success" title="配置成功"></p>
<h3 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h3><p><img src="/images/create-repository.png" alt="create Repository" title="创建Repository"><br><strong>注 :Repository name为 用户名.github.io</strong><br>我已经创建了，所以会有错误的提示。</p>
<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>hexo是一款基于Node.js的静态博客框架。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>安装<a href="https://nodejs.org/en/">Node.js</a>。去官网上下载，直接安装就可以。<br>NPM(Node Package Manager) 是Node.js的包管理器，Node.js中的带有NPM。</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><h4 id="创建Hexo-项目"><a href="#创建Hexo-项目" class="headerlink" title="创建Hexo 项目"></a>创建<a href="https://www.npmjs.com/package/hexo">Hexo</a> 项目</h4><p>控制台命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>查看Hexo版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo version </span><br></pre></td></tr></table></figure>
<p>创建项目(blog)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>进入项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure>
<p>安装依赖包(任何一个项目都要在项目目录下安装依赖包)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>启动项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>


<p>目录结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|─── .deploy       #需要部署的文件</span><br><span class="line">|─── node_modules  #Hexo插件</span><br><span class="line">|─── public        #生成的静态网页文件</span><br><span class="line">|─── scaffolds     #模板</span><br><span class="line">|─── source        #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</span><br><span class="line">|   |─── _drafts   #草稿</span><br><span class="line">|   |─── _posts    #文章</span><br><span class="line">|─── themes        #主题</span><br><span class="line">|─── _config.yml   #全局配置文件</span><br><span class="line">|─── package.json</span><br></pre></td></tr></table></figure>
<p>用浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a> 或者 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a> 就可以看到网页。<br>如果可以访问这个网页，就说明hexo搭建成功。</p>
<p>hexo常用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init [folder] #新建一个网站，如果没有设置folder，hexo默认在目前的文件夹建立网站</span><br><span class="line">hexo new [layout] &lt;title&gt; #新建一篇文章。如果没有设置layout的话，默认使用 _config.yml 中的default_layout参数代替，默认为post。</span><br><span class="line">hexo generate #生成静态文件。参数-d(--deploy文件生成后立即部署网站)、-w(--watch监视文件变动)</span><br><span class="line">hexo publish [layout] &lt;filename&gt; #发布草稿</span><br><span class="line">hexo server #启动服务器。参数-p(--port 重设端口)、-s(--static 只使用静态文件)、-l(--log 启动日志记录，或者覆盖格式记录)</span><br><span class="line">hexo deploy #部署网站。参数 -g(--generate 部署网站之前，需要预先生成静态文件)</span><br><span class="line">hexo clean #清除缓存文件(db.json)和已生成的静态文件(public)</span><br><span class="line">hexo list &lt;type&gt; #列出网站资料</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<code>hexo new [layout] &lt;title> </code>中的layout<br>hexo有三种默认布局<code>post</code>,<code>page</code>和<code>draft</code>,它们分别对应不同的路径而您自定义的其他布局和<code>post</code> 相同,都将储存到<code>source/_posts</code> 文件夹.</p>
</blockquote>
<h4 id="定制Hexo"><a href="#定制Hexo" class="headerlink" title="定制Hexo"></a>定制Hexo</h4><p>Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。<br>为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。</p>
<p><strong>注意：配置文件中的冒号”:”后面至少有一个空格,否则会报错.<a href="http://www.yaml.org/">YAML</a>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line"></span><br><span class="line">title: ShareKnowledge  #标题</span><br><span class="line">subtitle: #副标题</span><br><span class="line">description: 船头爱茶包......有人爱茶包 #描述</span><br><span class="line">author: ShareKl #作者</span><br><span class="line">language: zh-Hans #语言 汉语</span><br><span class="line">timezone:</span><br><span class="line"># header</span><br><span class="line">avatar: /head.jpg #头像信息 ，images 在source目录下</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">## url 在本地测试时，可以为空</span><br><span class="line">url: http://sharekl.github.io/</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/ #文章链接格式</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source #源文件目录</span><br><span class="line">public_dir: public #生成的网页文件目录</span><br><span class="line">tag_dir: tags #标签目录</span><br><span class="line">archive_dir: archives #归档目录</span><br><span class="line">category_dir: categories #分类目录</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight: #语法高亮</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true #行号</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"># Archives</span><br><span class="line">##2: 开启分页</span><br><span class="line">##1: 禁用分页</span><br><span class="line">##0: 全部禁用</span><br><span class="line">archive: 2</span><br><span class="line">category: 2</span><br><span class="line">tag: 2</span><br><span class="line"># Server #本地服务器</span><br><span class="line">port: 4000 #端口号</span><br><span class="line">server_ip: localhost #IP 地址</span><br><span class="line">logger: false</span><br><span class="line">logger_format: dev</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line">#下文详细解释 拓展插件、社交系统和主题设置</span><br><span class="line"># Extensions 拓展插件 </span><br><span class="line">##duoshuo_shortname  多说插件</span><br><span class="line">duoshuo_shortname: xxxxxxxxxxxxxxxxxxx</span><br><span class="line">##baidu_analytics  百度统计</span><br><span class="line">baidu_analytics: xxxxxxxxxxxxxxxxxxx</span><br><span class="line">##swiftype_key 搜索</span><br><span class="line">swiftype_key: xxxxxxxxxxxxxxxxxxx</span><br><span class="line">## Social links 社交系统</span><br><span class="line">social:</span><br><span class="line">  github:</span><br><span class="line">   href: https://github.com/ShareKl</span><br><span class="line">   img: /logo/github.png</span><br><span class="line">  douban: </span><br><span class="line">    href: http://www.douban.com/people/sharekl/</span><br><span class="line">    img: /logo/douban.png</span><br><span class="line">  weibo: </span><br><span class="line">   href: http://weibo.com/shareklg</span><br><span class="line">   img: /logo/sinaweibo.png</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">## Themes: http://hexo.io/themes/</span><br><span class="line">theme: next  ##主题设置 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## title, chinese available</span><br><span class="line">##links_title: Links</span><br><span class="line">## links</span><br><span class="line">##links:</span><br><span class="line">## MacTalk: http://macshuo.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此部分只是用来部署的，在本地测试无需修改</span><br><span class="line"># Deployment 将ShaerKl换成自己的github的用户名</span><br><span class="line">## Docs: http://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/ShareKl/ShareKl.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p><strong>修改主题</strong><br>我用的是<a href="http://notes.iissnan.com/">NexT主题</a>。<a href="http://theme-next.iissnan.com/">NexT帮助</a></p>
<p>下载主题<br>使用Git终端在终端窗口下，定位到 Hexo 站点目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>启用NexT主题<br>克隆/下载 完成后，打开 站点配置文件，找到 <code>theme</code> 字段，并将其值更改为 <code>next</code></p>
<p>主题设定<br>选择Scheme<br>NexT 通过 Scheme 提供主题中的主题。 Mist 是 NexT 的第一款 Scheme。启用 Mist 仅需在 主题配置文件 中将 #scheme: Mist 前面的 # 注释去掉即可。</p>
<p>语言设置<br>编辑站点配置文件，将 language 设置成你所需要的语言<br><code>language: zh-Hans</code></p>
<p>头像设置<br>编辑 站点配置文件，新增字段 avatar， 值设置成头像的链接地址。<br>头像设置示例：<br><code> avatar: <a href="http://sharekl.github.io/head.jpg">http://sharekl.github.io/head.jpg</a> </code><br><code> avatar: /avatar.jpg </code></p>
<p><strong>拓展插件</strong><br><a href="http://duoshuo.com/">多说</a>评论系统</p>
<blockquote>
<p>登录后在首页选择 “我要安装”。<br>创建站点，填写站点相关信息。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图：<br><img src="/images/duoshuo-create-site.png" alt="多说评论" title="多说评论"><br>创建站点完成后在 站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值。</p>
</blockquote>
<p><a href="http://tongji.baidu.com/web/welcome/login">百度统计</a></p>
<blockquote>
<p>登录 百度统计，定位到站点的代码获取页面<br>复制 hm.js? 后面那串统计脚本 id，如：<br><img src="/images/analytics-baidu-id.png" alt="百度统计" title="百度统计"><br>编辑站点配置文件，新增字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。</p>
</blockquote>
<p><a href="https://swiftype.com/">Swiftype 搜索</a></p>
<blockquote>
<p>前往 Swiftype 注册页面，注册一个新账户。<br>注册完成后，创建一个新的搜索引擎，并按照提示完成创建步骤。<br>搜索引擎创建完成后，在菜单中选择 Integrate -&gt; Install Search 开启搜索定制，安装步骤完成定制。最后一步记得点击 Active 按钮。<br>返回定制引擎的第二个步骤 INSTALL CODE，复制出你的 swiftype_key。<br><img src="/images/swiftype-create-id.png" alt="Swiftype 搜索" title="Swiftype 搜索"><br>编辑站点配置文件，新增字段 swiftype_key，值设置成第四步中赋值出来的 key</p>
</blockquote>
<p><strong>Social links 社交系统</strong><br>原主题的社交系统是不同于我这个社交系统的。<a href="http://notes.iissnan.com/">原主题网站</a>   <a href="http://sharekl.github.io/">我的博客网站</a><br>所以要修改主题的布局文件，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  github:</span><br><span class="line">   href: https://github.com/ShareKl</span><br><span class="line">   img: /logo/github.png</span><br><span class="line">  douban: </span><br><span class="line">    href: http://www.douban.com/people/sharekl/</span><br><span class="line">    img: /logo/douban.png</span><br><span class="line">  weibo: </span><br><span class="line">   href: http://weibo.com/shareklg</span><br><span class="line">   img: /logo/sinaweibo.png</span><br></pre></td></tr></table></figure>
<p>修改themes\next\layout_macro\sidebar.swig</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原67行&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt;</span><br><span class="line">修改为&lt;a href=&quot;&#123;&#123; link.href &#125;&#125;&quot; target=&quot;_blank&quot; style=&quot;border-bottom: 0px&quot;&gt;&lt;img src=&quot;&#123;&#123; link.img &#125;&#125;&quot;&gt;&lt;/img&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="部署Hexo到Git"><a href="#部署Hexo到Git" class="headerlink" title="部署Hexo到Git"></a>部署Hexo到Git</h4><p>编辑站点配置文件,把deploy信息配置好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/ShareKl/ShareKl.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>ShareKl 为自己的用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean #先清空下文件</span><br><span class="line">hexo generate #再生成</span><br><span class="line">hexo d #部署</span><br></pre></td></tr></table></figure>


<h1 id="错误及解决办法"><a href="#错误及解决办法" class="headerlink" title="错误及解决办法"></a>错误及解决办法</h1><h2 id="hexo-ERROR-Deployer-not-found-github"><a href="#hexo-ERROR-Deployer-not-found-github" class="headerlink" title="hexo ERROR Deployer not found: github"></a>hexo ERROR Deployer not found: github</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repo: https://github.com/ShareKl/ShareKl.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p><code>type: github</code> 部署不成功的话，安装<code>npm install hexo-deployer-git --save</code><br>然后将deploy的type由github修改为git</p>
<h2 id="执行hexo-d-报错Error-spawn-git-ENOENT"><a href="#执行hexo-d-报错Error-spawn-git-ENOENT" class="headerlink" title="执行hexo d 报错Error: spawn git ENOENT"></a>执行hexo d 报错Error: spawn git ENOENT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: spawn git ENOENT</span><br><span class="line">    at exports._errnoException (util.js:746:11)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (child_process.js:1053:32)</span><br><span class="line">    at child_process.js:1144:20</span><br><span class="line">    at process._tickCallback (node.js:355:11)</span><br></pre></td></tr></table></figure>
<p>解决方法<br>添加环境变量：C:\Program Files (x86)\Git\bin;C:\Program Files (x86)\Git\libexec\git-core，这样就解决了问题了。</p>
<h1 id="高阶设置"><a href="#高阶设置" class="headerlink" title="高阶设置"></a>高阶设置</h1><p>SEO优化</p>
]]></content>
      <tags>
        <tag>blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 安装 OpenSSH</title>
    <url>/winssh.html</url>
    <content><![CDATA[<p>从 Win10 1809 和 Windows Server 2019 开始 Windows 开始支持 OpenSSH Server. 本文介绍如何在 Win10 下安装 OpenSSH Server.</p>
<p>Win10下已经默认安装 OpenSSH Client</p>
<span id="more"></span>
<h1 id="安装OpenSSH-Server"><a href="#安装OpenSSH-Server" class="headerlink" title="安装OpenSSH Server"></a>安装OpenSSH Server</h1><p>打开 Settings(设置) &gt; Apps(应用)&gt; Manage optional features(管理可选功能)</p>
<p><img src="/images/openssh.jpg" alt="可选功能(本图为已经安装OpenSSH Server图)"></p>
<p>如果没有安装, 点击 Add a feature(添加功能), 然后安装OpenSSH Server</p>
<h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><ol>
<li><p>打开服务管理器</p>
<p> 在”运行”对话框下输入 <code>services.msc</code></p>
</li>
<li><p>开启 OpenSSH 服务</p>
<p> 找到 OpenSSH SSH Server 和 OpenSSH Authentication Agent 右键, 启动</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
